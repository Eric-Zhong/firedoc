{
  "project": {
    "name": "firedoc",
    "version": "1.8.0",
    "author": "Dav Glass <davglass@gmail.com>",
    "bugs": {
      "url": "http://github.com/fireball-x/firedoc/issues"
    },
    "contributors": [
      {
        "name": "Adam Moore",
        "email": "amoore@gmail.com"
      },
      {
        "name": "Ryan Grove",
        "email": "ryan@wonko.com"
      },
      {
        "name": "Eric Ferraiuolo",
        "email": "eferraiuolo@gmail.com"
      },
      {
        "name": "Felipe Gasper",
        "email": "felipe@cpanel.net"
      },
      {
        "name": "Evan Goer",
        "email": "evan@goer.org"
      },
      {
        "name": "Alberto Gragera",
        "email": "albgra@gmail.com"
      },
      {
        "name": "Pat Cavit",
        "email": "pcavit@gmail.com"
      },
      {
        "name": "Kazuhito Hokamura",
        "email": "k.hokamura@gmail.com"
      },
      {
        "name": "prodaea",
        "email": "rlee@etherealnation.net"
      },
      {
        "name": "Wei Wang",
        "email": "weiwang85@gmail.com"
      },
      {
        "name": "Thomas Boyt",
        "email": "me@thomasboyt.com"
      },
      {
        "name": "Yorkie Liu",
        "email": "yorkiefixer@gmail.com"
      },
      {
        "name": "Nan Wang",
        "email": "nantas@gmail.com"
      }
    ],
    "engines": {
      "node": ">=0.12.0"
    },
    "keywords": [
      "jsdoc",
      "api",
      "documentation",
      "javadoc",
      "docs",
      "apidocs"
    ],
    "main": "./lib/firedoc",
    "bin": {
      "firedoc": "./bin/firedoc.js"
    },
    "dependencies": {
      "bluebird": "^2.9.30",
      "commander": "^2.8.1",
      "debug": "^2.2.0",
      "express": "^4.12.3",
      "fs-extra": "^0.20.1",
      "glob": "^5.0.10",
      "graceful-fs": "2.x",
      "handlebars": "^3.0.3",
      "markdown-it": "^4.2.2",
      "minimatch": "^2.0.1",
      "mkdirp": "^0.5.1",
      "needle": "^0.9.2",
      "readdirp": "^1.3.0",
      "rimraf": "2.x",
      "rmdir": "^1.1.0",
      "serve": "^1.4.0",
      "underscore": "^1.8.3"
    },
    "devDependencies": {
      "istanbul": "^0.3.16",
      "jshint": "^2.6.0",
      "mocha": "^2.2.5",
      "sinon": "^1.15.4"
    },
    "scripts": {
      "docs": "make docs",
      "pretest": "jshint ./lib/*.js",
      "test": "make test"
    },
    "preferGlobal": "true",
    "licenses": [
      {
        "type": "BSD",
        "url": "https://github.com/fireball-x/firedoc/blob/master/LICENSE"
      }
    ],
    "repository": {
      "type": "git",
      "url": "http://github.com/fireball-x/firedoc.git"
    },
    "jshintConfig": {
      "bitwise": true,
      "browser": true,
      "curly": true,
      "eqeqeq": true,
      "forin": true,
      "immed": true,
      "latedef": "nofunc",
      "laxbreak": true,
      "maxerr": 500,
      "maxlen": 150,
      "newcap": true,
      "noarg": true,
      "node": true,
      "noempty": true,
      "onevar": true,
      "trailing": true,
      "undef": true,
      "unused": "vars",
      "yui": true
    }
  },
  "files": [
    {
      "name": "lib_ast.js",
      "classes": {},
      "modules": {},
      "fors": {
        "DocParser": 1
      },
      "namespaces": {},
      "code": "\n/**\n * @module firedoc\n */\n\nconst _ = require('underscore');\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst utils = require('./utils');\nconst debug = require('debug')('firedoc:ast');\nconst ParserContext = require('./context').ParserContext;\nconst CWD = process.cwd();\nconst REGEX_TYPE = /(.*?)\\{(.*?)\\}(.*)/;\nconst REGEX_LINES = /\\r\\n|\\n/;\nconst REGEX_GLOBAL_LINES = /\\r\\n|\\n/g;\nconst REGEX_FIRSTWORD = /^\\s*?(\\[([^\\[\\]]+)\\]\\*?|[^\\s]+)\\s*\\-?\\s*(.*)/;\nconst REGEX_OPTIONAL = /^\\[(.*)\\]$/;\nconst REGEX_START_COMMENT = {\n  js: /^\\s*\\/\\*\\*/,\n  coffee: /^\\s*###\\*/\n};\nconst REGEX_END_COMMENT = {\n  js: /\\*\\/\\s*$/,\n  coffee: /###\\s*$/\n};\nconst REGEX_LINE_HEAD_CHAR = {\n  js: /^\\s*\\*/,\n  coffee: /^\\s*[#\\*]/\n};\n\n/**\n * A list of ignored tags. These tags should be ignored because there is\n * likely to be used for purposes other than JSDoc tags in JavaScript comments.\n * @property IGNORE_TAGLIST\n * @type Array\n * @final\n * @for DocParser\n */\nconst IGNORE_TAGLIST = ['media'];\n\n/**\n * Common errors will get scrubbed instead of being ignored.\n * @property CORRECTIONS\n * @type Object\n * @final\n */\nconst CORRECTIONS = {\n  'augments': 'uses', // YUI convention for prototype mixins\n  'depreciated': 'deprecated', // subtle difference\n  'desciption': 'description', // shouldn't need the @description tag at all\n  'extend': 'extends', // typo\n  'function': 'method', // we may want standalone inner functions at some point\n  'member': 'method', // probably meant method\n  'parm': 'param', // typo\n  'params': 'param', // typo\n  'pamra': 'param', // typo\n  'parma': 'param', // typo\n  'propery': 'property', // typo\n  'prop': 'property', // probably meant property\n  'returns': 'return' // need to standardize on one or the other\n};\n\n/**\n *\n */\nconst SHORT_TAGS = {\n  'async': 1,\n  'beta': 1,\n  'chainable': 1,\n  'extends': 1,\n  'final': 1,\n  'static': 1,\n  'optional': 1,\n  'required': 1\n};\n\n\n/**\n * A list of known tags.  This populates a member variable\n * during initialization, and will be updated if additional\n * digesters are added.\n *\n * @property TAGLIST\n * @type Array\n * @final\n * @for DocParser\n */\nconst TAGLIST = [\n  \"async\",        // bool, custom events can fire the listeners in a setTimeout\n  \"author\",       // author best for projects and modules, but can be used anywhere // multi\n  \"attribute\",    // YUI attributes -- get/set with change notification, etc\n  \"beta\",         // module maturity identifier\n  \"broadcast\",    // bool, events\n  \"bubbles\",      // custom events that bubble\n  \"callback\",     // callback defines\n  \"category\",     // modules can be in multiple categories\n  \"chainable\",    // methods that return the host object\n  \"class\",        // pseudo class\n  \"conditional\",  // conditional module\n  \"config\",       // a config param (not an attribute, so no change events)\n  \"const\",        // not standardized yet, converts to final property\n  \"constructs\",   // factory methods (not yet used)\n  \"constructor\",  // this is a constructor\n  \"contributor\",  // like author\n  \"default\",      // property/attribute default value\n  \"deprecated\",   // please specify what to use instead\n  \"description\",  // can also be free text at the beginning of a comment is\n  \"emitfacade\",   // bool, YUI custom event can have a dom-like event facade\n  \"enum\",         // pseudo enum\n  \"event\",        // YUI custom event\n  \"evil\",         // uses eval\n  \"extension\",    // this is an extension for [entity]\n  \"extensionfor\", // this is an extension for [entity]\n  \"extension_for\",// this is an extension for [entity]\n  \"example\",      // 0..n code snippets.  snippets can also be embedded in the desc\n  \"experimental\", // module maturity identifier\n  \"extends\",      // pseudo inheritance\n  \"file\",         // file name (used by the parser)\n  \"final\",        // not meant to be changed\n  \"fireonce\",     // bool, YUI custom event config allows\n  \"for\",          // used to change class context\n  \"global\",       // declare your globals\n  \"icon\",         // project icon(s)\n  \"in\",           // indicates module this lives in (obsolete now)\n  \"initonly\",     // attribute writeonce value\n  \"injects\",      // injects {HTML|script|CSS}\n  \"knownissue\",   // 0..n known issues for your consumption\n  \"line\",         // line number for the comment block (used by the parser)\n  \"method\",       // a method\n  \"module\",       // YUI module name\n  \"main\",         // Description for the module\n  \"optional\",     // For optional attributes\n  \"required\",     // For required attributes\n  \"param\",        // member param\n  \"plugin\",       // this is a plugin for [entityl]\n  \"preventable\",  // YUI custom events can be preventable ala DOM events\n  \"private\",      // > access\n  'process',      // instance runtime\n  \"project\",      // project definition, one per source tree allowed\n  'logo',         // project logo\n  \"property\",     // a regular-ole property\n  \"protected\",    // > access\n  \"public\",       // > access\n  \"queuable\",     // bool, events\n  \"readonly\",     // YUI attribute config\n  \"requires\",     // YUI module requirements\n  \"return\",       // {type} return desc -- returns is converted to this\n  \"see\",          // 0..n things to look at\n  \"since\",        // when it was introduced\n  \"static\",       // static\n  \"submodule\",    // YUI submodule\n  \"throws\",       // {execption type} description\n  \"title\",        // this should be something for the project description\n  \"todo\",         // 0..n things to revisit eventually (hopefully)\n  \"type\",         // the var type\n  \"url\",          // project url(s)\n  \"uses\",         // 0..n compents mixed (usually, via augment) into the prototype\n  \"value\",        // the value of a constant\n  \"writeonce\"     // YUI attribute config\n];\n\nvar InitialAST;\n\n/**\n * The AST(Abstract syntax tree) of the comment\n *\n * @class AST\n */\nvar AST = {\n  \n  /**\n   * @property {Object} project - About the project\n   */\n  project: {},\n\n  /**\n   * @property {Object} files - The files\n   */\n  files: {},\n\n  /**\n   * @property {Object} codes - The source codes\n   */\n  codes: {},\n\n  /**\n   * @property {Object} modules - The modules\n   */\n  modules: {},\n\n  /**\n   * @property {Object} classes - The classes\n   */\n  classes: {},\n\n  /**\n   * @property {Array} members - The members\n   */\n  members: [],\n\n  /**\n   * @property {Array} inheritedMembers - The inherited members\n   */\n  inheritedMembers: [],\n\n  /**\n   * @property {Object} namespacesMap - The namespaces map object\n   */\n  namespacesMap: {},\n\n  /**\n   * @property {Object} commentsMap - The comments map object\n   */\n  commentsMap: {},\n\n  /**\n   * @property {String} syntaxType - The syntax type\n   */\n  syntaxType: 'js',\n\n  /**\n   * @property {Context} context - The context object\n   */\n  context: null,\n\n  /**\n   * @proerty {Array} warnings - The parser warnings\n   */\n  warnings: [],\n\n  /**\n   * Create a AST object\n   *\n   * @method create\n   * @param {Object} files - The files\n   * @param {Object} dirs - The directorys\n   * @param {String} [syntaxType] - The syntax type: `coffee` or `js`\n   * @return {AST} the created AST object\n   */\n  create: function (files, dirs, syntaxType) {\n    var instance = AST;\n    instance.syntaxType = syntaxType || instance.syntaxType;\n    instance.context = ParserContext;\n    instance.context.ast = instance;\n    instance.extract(files, dirs);\n    instance.transform();\n    return instance;\n  },\n\n  /**\n   * Reset the AST instance\n   *\n   * @method reset\n   */\n  reset: function () {\n    AST.project = {};\n    AST.files = {};\n    AST.codes = {};\n    AST.modules = {};\n    AST.classes = {};\n    AST.members = [];\n    AST.inheritedMembers = [];\n    AST.commentsMap = {};\n    AST.syntaxType = 'js';\n    AST.warnings = [];\n    if (AST.context && AST.context.reset) {\n      AST.context.reset();\n      AST.context = null;\n    }\n    return AST;\n  },\n\n  /**\n   *\n   * @method oncomment\n   * @param {String} comment\n   * @param {String} filename\n   * @param {String} linenum\n   * @return {Object}\n   */\n  oncomment: function (comment, filename, linenum) {\n    var lines = comment.split(REGEX_LINES);\n    const len = lines.length;\n    const lineHeadCharRegex = REGEX_LINE_HEAD_CHAR[this.syntaxType];\n    const hasLineHeadChar = lines[0] && lineHeadCharRegex.test(lines[0]);\n    const r = new RegExp('(?:^|\\\\n)\\\\s*((?!@' + IGNORE_TAGLIST.join(')(?!@') + ')@\\\\w*)');\n\n    var results = [\n      {\n        'tag': 'file',\n        'value': filename\n      },\n      {\n        'tag': 'line',\n        'value': linenum\n      }\n    ];\n\n    if (hasLineHeadChar) {\n      lines = _.map(lines, function (line) {\n        return line.trim().replace(lineHeadCharRegex, '');\n      });\n    }\n\n    const unidented = utils.unindent(lines.join('\\n'));\n    const parts = unidented.split(r);\n\n    var cursor = 0;\n    for (; cursor < parts.length; cursor++) {\n      var skip;\n      var val = '';\n      var part = parts[cursor];\n      if (part === '') continue;\n\n      skip = false;\n      // the first token may be the description, otherwise it should be a tag\n      if (cursor === 0 && part.substr(0, 1) !== '@') {\n        if (part) {\n          tag = '@description';\n          val = part;\n        } else {\n          skip = true;\n        }\n      } else {\n        tag = part;\n        // lookahead for the tag value\n        var peek = parts[cursor + 1];\n        if (peek) {\n          val = peek;\n          cursor += 1;\n        }\n      }\n      if (!skip && tag) {\n        results.push({\n          tag: tag.substr(1).toLowerCase(),\n          value: val || ''\n        });\n      }\n    }\n    return results;\n  },\n\n  /**\n   * Processes all the tags in a single comment block\n   * @method onblock\n   * @param {Array} an array of the tag/text pairs\n   */\n  onblock: function (block) {\n    this.context.block = {\n      'self': block,\n      'target': {\n        'file': this.context.file,\n        'line': block[1].value,\n        '_raw': _.reduce(block, onreduce, {})\n      },\n      'host': null,\n      'digesters': []\n    };\n\n    function onreduce (map, item) {\n      var key = utils.safetrim(item.tag);\n      var val = utils.safetrim(item.value);\n      map[key] = _.isString(val) ? utils.safetrim(val) : val;\n      return map;\n    }\n\n    // handle tags and push digesters to context.block.digesters\n    _.each(block, this.ontag, this);\n    // run digiesters\n    _.each(this.context.block.digesters, ondigester, this);\n\n    function ondigester (ctx) {\n      var ret = ctx.fn.call(this, ctx.name, ctx.value,\n        this.context.block.target, this.context.block.self);\n      this.context.block.host = this.context.block.host || ret;\n    }\n\n    // post process\n    if (this.context.block.host) {\n      _.extend(this.context.block.host, this.context.block.target);\n    } else {\n      var target = this.context.block.target;\n      target.clazz = this.context.clazz;\n      target.module = this.context.module;\n      target.isGlobal = (this.context.clazz === '');\n      target.submodule = this.context.submodule;\n\n      // set namespace\n      var ns = utils.getNamespace(target);\n      if (ns) {\n        this.namespacesMap[ns] = target;\n        target.namespace = ns;\n\n        var parent = this.classes[target.clazz] || this.modules[target.module];\n        Object.defineProperty(target, 'parent', {\n          enumerable: true,\n          get: function () {\n            return parent;\n          }\n        });\n\n        target.process = target.process || parent.process;\n      }\n\n      if (target.itemtype) {\n        this.members.push(target);\n      } else if (target.isTypeDef) {\n        var parent = this.classes[this.context.clazz] ||\n          this.modules[this.context.module];\n        if (!parent) return;\n        parent.types[target.name] = target;\n      }\n    }\n  },\n\n  /**\n   * Process tag\n   * @method ontag\n   * @param {Object} item\n   * @param {String} item.tag\n   * @param {Object} item.value\n   */\n  ontag: function (item) {\n    var name = utils.safetrim(item.tag);\n    var value = utils.safetrim(item.value);\n\n    if (SHORT_TAGS[name] && value === '') {\n      value = 1;\n    }\n\n    if (TAGLIST.indexOf(name) === -1) {\n      if (_.has(CORRECTIONS, name)) {\n        // correction part\n        // TODO(Yorkie): log the correction\n        name = CORRECTIONS[name];\n        item.tag = name;\n      } else {\n        // TODO(Yorkie): report the unknown correction\n      }\n    }\n\n    if (_.has(DIGESTERS, name) === -1) {\n      this.context.block.target[name] = value;\n    } else {\n      var digest = DIGESTERS[name];\n      if (_.isString(digest)) {\n        digest = DIGESTERS[digest];\n      }\n      var block = this.context.block;\n      _.each(block.self, function (item) {\n        if (item.tag === 'description') {\n          block.target.description = item.value;\n        } else if (item.tag === 'type') {\n          block.target.type = utils.fixType(item.value);\n        } else if (item.tag === 'extends') {\n          block.target.extends = utils.fixType(item.value);\n        }\n      });\n      if (_.isFunction(digest)) {\n        // here we only push and run later\n        // because CORRECTION perhaps doesn't apply the later tags.\n        block.digesters.push({\n          fn: digest,\n          name: name,\n          value: value\n        });\n      }\n    }\n  },\n\n  /**\n   * Accepts a map of filenames to file content.  Returns\n   * a map of filenames to an array of API comment block\n   * text.  This expects the comment to start with / **\n   * on its own line, and end with * / on its own\n   * line.  Override this function to provide an\n   * alternative comment parser.\n   *\n   * @method extract\n   * @param {Object} files\n   * @param {Object} dirs\n   */\n  extract: function (files, dirs) {\n    _.each(files, function (code, filename) {\n      filename = path.relative(CWD, filename);\n      this.codes[filename] = code;\n      const lines = code.split(REGEX_LINES);\n      const len = lines.length;\n      var comment;\n      var cursor = 0;\n      for (; cursor < len; cursor++) {\n        var line = lines[cursor];\n        if (REGEX_START_COMMENT[this.syntaxType].test(line)) {\n          var comments = [];\n          var linenum = cursor + 1;\n          while (cursor < len &&\n            (!REGEX_END_COMMENT[this.syntaxType].test(line))) {\n            comments.push(line);\n            cursor += 1;\n            line = lines[cursor];\n          }\n          comments.shift();\n          comment = comments.join('\\n');\n          this.commentsMap[filename] = this.commentsMap[filename] || [];\n          this.commentsMap[filename].push(this.oncomment(comment, filename, linenum));\n        }\n      }\n    }, this);\n  },\n\n  /**\n   * Transforms a map of filenames to arrays of comment blocks into a\n   * JSON structure that represents the entire processed API doc info\n   * and relationships between elements for the entire project.\n   *\n   * @method transform\n   * @param {Object} commentmap The hash of files and parsed comment blocks\n   * @return {Object} The transformed data for the project\n   */\n  transform: function () {\n    _.each(this.commentsMap, function (blocks, filename) {\n      this.context.file = filename;\n      _.each(blocks, this.onblock, this);\n    }, this);\n  }\n\n};\n\n/**\n * A map of the default tag processors, keyed by the\n * tag name.  Multiple tags can use the same digester\n * by supplying the string name that points to the\n * implementation rather than a function.\n * @property DIGESTERS\n * @type Object\n * @final\n * @for DocParser\n */\nconst DIGESTERS = {\n  'param': function (tagname, value, target, block) {\n    target.params = target.params || [];\n    if (!value) {\n      this.warnings.push({\n        message: 'param name/type/descript missing',\n        line: utils.stringlog(block)\n      });\n      console.warn('param name/type/descript missing: ' + utils.stringlog(block));\n      return;\n    }\n\n    var type, name, parts, optional, optdefault, parent, multiple, len, result,\n      desc = implodeString(utils.safetrim(value)),\n      match = REGEX_TYPE.exec(desc),\n      host = target.params,\n      type_;\n\n    // Extract {type}\n    if (match) {\n      type_ = utils.safetrim(match[2]);\n      type = utils.safetrim(match[2]);\n      desc = utils.safetrim(match[1] + match[3]);\n    }\n\n    // extract the first word, this is the param name\n    match = REGEX_FIRSTWORD.exec(desc);\n    if (match) {\n      name = utils.safetrim(explodeString(match[1]));\n      desc = utils.safetrim(match[3]);\n    }\n\n    if (!name) {\n      if (value && value.match(/callback/i)) {\n        this.warnings.push({\n          message: 'Fixing missing name for callback',\n          line: utils.stringlog(block)\n        });\n        console.warn('Fixing missing name for callback:' + utils.stringlog(block));\n        name = 'callback';\n        type = 'Callback';\n      } else {\n        this.warnings.push({\n          message: 'param name missing: ' + value,\n          line: utils.stringlog(block)\n        });\n        console.warn('param name missing: ' + value + ':' + utils.stringlog(block));\n        name = 'UNKNOWN';\n      }\n    }\n\n    len = name.length - 1;\n    if (name.charAt(len) === '*') {\n        multiple = true;\n        name = name.substr(0, len);\n    }\n\n    // extract [name], optional param\n    if (name.indexOf('[') > -1) {\n      match = REGEX_OPTIONAL.exec(name);\n      if (match) {\n        optional = true;\n        name = utils.safetrim(match[1]);\n        // extract optional=defaultvalue\n        parts = name.split('=');\n        if (parts.length > 1) {\n          name = parts[0];\n          optdefault = parts[1];\n          //Add some shortcuts for object/array defaults\n          if (optdefault.toLowerCase() === 'object') {\n            optdefault = '{}';\n          }\n          if (optdefault.toLowerCase() === 'array') {\n            optdefault = '[]';\n          }\n        }\n      }\n    }\n\n    // This should run after the check for optional parameters\n    // and before the check for child parameters\n    // because the signature for 0..n params is [...args]\n    if (name.substr(0, 3) === '...') {\n      multiple = true;\n      name = name.substr(3);\n    }\n\n    // parse object.prop, indicating a child property for object\n    if (name.indexOf('.') > -1) {\n      match = name.split('.');\n      parent = utils.safetrim(match[0]);\n      _.each(target.params, function (param) {\n        if (param.name === parent) {\n          param.props = param.props || [];\n          host = param.props;\n          match.shift();\n          name = utils.safetrim(match.join('.'));\n          if (match.length > 1) {\n            var pname = name.split('.')[0], par;\n            _.each(param.props, function (o) {\n              if (o.name === pname) {\n                par = o;\n              }\n            });\n            if (par) {\n              match = name.split('.');\n              match.shift();\n              name = match.join('.');\n              par.props = par.props || [];\n              host = par.props;\n            }\n          }\n        }\n      });\n    }\n\n    result = {\n      name: name,\n      description: explodeString(desc)\n    };\n\n    if (type) {\n      // find types from classitems\n      var item = _.findWhere(this.members, {'name': type});\n      if (!item && this.context.clazz) {\n        item = this.classes[this.context.clazz].types[type];\n      }\n      if (!item && this.context.module) {\n        item = this.modules[this.context.module].types[type];\n      }\n      // finded the type\n      if (item && item.params) {\n        // Dont remove the clone, because the item.params will be\n        // used by multiple results, so that we need to clone a new\n        // one for its own usage.\n        result.description = result.description || item.description;\n        result.props = _.clone(item.params);\n        result.type = type_;\n      } else {\n        result.type = type;\n      }\n    }\n\n    if (optional) {\n      result.optional = true;\n      if (optdefault) {\n        result.optdefault = optdefault;\n      }\n    }\n\n    if (multiple) {\n      result.multiple = true;\n    }\n\n    // localize the description\n    result.description = utils.localize(result.description);\n\n    // push localized result to host\n    host.push(result);\n  },\n\n  // @return {type} description // methods\n  // @returns {type} description // methods\n  // @injects {HTML|CSS|script} description\n  // can be used by anthing that has an optional {type} and a description\n  'return': function (tagname, value, target, block) {\n    var desc = implodeString(utils.safetrim(value)),\n      type,\n      match = REGEX_TYPE.exec(desc),\n      result = {};\n\n    if (match) {\n      type = utils.safetrim(match[2]);\n      desc = utils.safetrim(match[1] + match[3]);\n    }\n\n    result = {\n      description: utils.unindent(explodeString(desc))\n    };\n\n    if (type) {\n      result.type = type;\n    }\n\n    // remove the fist char '-' for @return tag\n    result.description = result.description.replace(/^\\s?-\\s?/, '');\n\n    // localize the description\n    result.description = utils.localize(result.description);\n\n    target[tagname] = result;\n  },\n\n  // @throws {type} description\n  'throws': 'return',\n\n  'injects': 'return',\n\n  // trying to overwrite the constructor value is a bad idea\n  'constructor': function (tagname, value, target, block) {\n    target.isConstructor = true;\n  },\n\n  // A key bock type for declaring modules and submodules\n  // subsequent class and member blocks will be assigned\n  // to this module.\n  'module': function (tagname, value, target, block) {\n    this.context.module = value;\n    if (target._raw.process) {\n      target.process = utils.fmtProcess(target._raw.process);\n    }\n    if (!target._raw.submodule) {\n      if (!this.context.mainModule) {\n        this.context.mainModule = {\n          tag: tagname,\n          name: value,\n          file: target.file,\n          line: target.line,\n          type: 'modules',\n          description: utils.localize(target.description)\n        };\n      }\n      target.file = this.context.mainModule.file;\n      target.line = this.context.mainModule.line;\n      return this.modules[value];\n    }\n    return null;\n  },\n\n  //Setting the description for the module..\n  'main': function (tagname, value, target, block) {\n    var o = target;\n    o.mainName = value;\n    o.tag = tagname;\n    o.itemtype = 'main';\n    o.description = utils.localize(o.description);\n    o._main = true;\n    this.context.mainModule = o;\n  },\n\n  // accepts a single project definition for the source tree\n  'project': function (tagname, value, target, block) {\n    this.project.name = value;\n    this.project.description = this.project.description || value;\n  },\n  \n  // accepts a single project logo definition\n  'logo': function (tagname, value, target, block) {\n    this.project.logo = value;\n  },\n\n  // A key bock type for declaring submodules.  subsequent class and\n  // member blocks will be assigned to this submodule.\n  'submodule': function (tagname, value, target, block) {\n    this.context.submodule = value;\n\n    var host = this.modules[value];\n    var clazz = this.context.clazz;\n    var parent = this.context.module;\n    if (parent) {\n      host.module = parent;\n      var parentModule = this.context.ast.modules[parent];\n      if (parentModule) {\n        this.context.ast.modules[parent].submodules[host.name] = host;\n      }\n    }\n    if (clazz && this.classes[clazz]) {\n      this.classes[clazz].submodule = value;\n    }\n    return host;\n  },\n\n  // this is a way to abstract the definitions of callback arguments\n  'callback': function (tagname, value, target, block) {\n    target.name = value;\n    target.isTypeDef = true;\n  },\n\n  // A key bock type for declaring classes, subsequent\n  // member blocks will be assigned to this class\n  'class': function (tagname, value, target, block) {\n    var self = this;\n    var fullname, host, parent;\n\n    // set the process and attach the process on `target`\n    if (target._raw.process) {\n      target.process = utils.fmtProcess(target._raw.process);\n    } else {\n      var modProcess = this.modules[this.context.module].process;\n      target.process = modProcess;\n    }\n\n    if (target._raw.extends) {\n      var extended = target._raw.extends;\n      if (!extended) {\n        console.warn('usage: `@extends <class>`, but only found `@extends`');\n      } else if (!this.inheritedMembers.length) {\n        this.inheritedMembers.push([extended, value]);\n      } else {\n        var needNewItem = true;\n        var item, at;\n        _.some(this.inheritedMembers, function (member) {\n          item = member;\n          at = member.indexOf(extended);\n          if (member.length - 1 === at) {\n            return true;  // break\n          }\n          if (member[at + 1] === value) {\n            needNewItem = false;\n            return true;\n          }\n          if (at !== -1) {\n            return true;\n          }\n        }, this);\n        if (needNewItem) {\n          if (extended !== item[item.length - 1]) {\n            var newItem = item.slice(0, at + 1);\n            newItem.push(value);\n            self.inheritedMembers.push(newItem);\n          } else {\n            item.push(value);\n          }\n        }\n      }\n    }\n    \n    this.context.clazz = value;\n\n    fullname = this.context.clazz;\n    host = this.classes[fullname];\n    parent = this.context.module;\n\n    if (parent) {\n      host.module = parent;\n    }\n\n    // set `is_enum` when the tagname is \"enum\"\n    if (tagname === 'enum') {\n      host.isEnum = true;\n      host.type = 'enums';\n    } else {\n      host.isEnum = false;\n      host.type = 'classes';\n    }\n\n    //Merge host and target in case the class was defined in a \"for\" tag\n    //before it was defined in a \"class\" tag\n    host = _.extend(host, target);\n    this.classes[fullname] = host;\n    parent = this.context.submodule;\n    if (parent) {\n      host.submodule = parent;\n    }\n\n    // localize\n    host.description = utils.localize(host.description);\n    return host;\n  },\n\n  // just defer from class in their names\n  'enum': 'class',\n\n  // change 'const' to final property\n  'const': function (tagname, value, target, block) {\n    target.itemtype = 'property';\n    target.name = value;\n    /*jshint sub:true */\n    target['final'] = '';\n  },\n\n  // supported classitems\n  'property': function (tagname, value, target, block) {\n    var match, name, desc, type;\n\n    target.itemtype = tagname;\n    target.name = value;\n\n    if (target._raw.process) {\n      target.process = utils.fmtProcess(target._raw.process);\n    }\n\n    if (tagname === 'property') {\n      var propM = value.match(/^\\{(.+)\\} ([a-zA-Z0-9_]+)\\s*\\-?\\s*(.+)?$/);\n      if (propM && propM.length === 4) {\n        value = propM[2];\n        target.type = propM[1];\n        target.name = propM[2];\n        target.description = propM[3];\n      }\n    }\n\n    if (!target.type) {\n      desc = implodeString(utils.safetrim(value));\n      match = REGEX_TYPE.exec(desc);\n\n      // Extract {type}\n      if (match) {\n        type = trim(match[2]);\n        name = trim(match[1] + match[3]);\n        target.type = type;\n        target.name = name;\n      }\n    }\n\n    // localize the description\n    target.description = utils.localize(target.description);\n  },\n  'method': 'property',\n  'attribute': 'property',\n  'config': 'property',\n  'event': 'property',\n\n  // access fields\n  'public': function (tagname, value, target, block) {\n    target.access = tagname;\n    target.tagname = value;\n  },\n  'private': 'public',\n  'protected': 'public',\n  'inner': 'public',\n\n  // tags that can have multiple occurances in a single block\n  'todo': function (tagname, value, target, block) {\n    if (!_.isArray(target[tagname])) {\n      target[tagname] = [];\n    }\n    //If the item is @tag one,two\n    if (value.indexOf(',') > -1) {\n      value = value.split(',');\n    } else {\n      value = [value];\n    }\n\n    value.forEach(function (v) {\n      v = trim(v);\n      target[tagname].push(v);\n    });\n  },\n  'extension_for': 'extensionfor',\n  'extensionfor': function (tagname, value, target, block) {\n    var clazz = this.context.clazz;\n    if (this.classes[clazz]) {\n      this.classes[clazz].extension_for.push(value);\n    }\n  },\n  'example': function (tagname, value, target, block) {\n    if (value) {\n      var linkMatch = value.match(/\\{@link (.+)\\}/);\n      if (linkMatch && linkMatch.length === 2) {\n        var relative = utils.safetrim(linkMatch[1]);\n        var examplePath = process.cwd() + '/' + relative;\n        if (fs.existsSync(examplePath)) {\n          value = fs.readFileSync(examplePath, 'utf8');\n          value = '```' + value;\n        } else {\n          value = '```Not found for the example path: ' + relative;\n        }\n      }\n    }\n\n    if (!_.isArray(target[tagname])) {\n      target[tagname] = [];\n    }\n\n    var e = value;\n    block.forEach(function (v) {\n      if (v.tag === 'example') {\n        if (v.value.indexOf(value) > -1) {\n          e = v.value;\n        }\n      }\n    });\n\n    target[tagname].push(e);\n  },\n  'url': 'todo',\n  'icon': 'todo',\n  'see': 'todo',\n  'requires': 'todo',\n  'knownissue': 'todo',\n  'uses': 'todo',\n  'category': 'todo',\n  'unimplemented': 'todo',\n\n  genericValueTag: function (tagname, value, target, block) {\n    target[tagname] = value;\n  },\n\n  'author': 'genericValueTag',\n  'contributor': 'genericValueTag',\n  'since': 'genericValueTag',\n\n  'deprecated': function (tagname, value, target, block) {\n    target.deprecated = true;\n    if (typeof value === 'string' && value.length) {\n      target.deprecationMessage = value;\n    }\n  },\n\n  // updates the current class only (doesn't create\n  // a new class definition)\n  'for': function (tagname, value, target, block) {\n    var ns, file, mod;\n    this.context.clazz = value;\n\n    ns = ((this.classes[value]) ? this.classes[value].namespace : '');\n    this.context.namespace = ns;\n\n    file = this.context.file;\n    if (file) {\n      this.files[file].fors[value] = 1;\n    }\n\n    mod = this.context.module;\n    if (mod) {\n      this.modules[mod].fors[value] = 1;\n    }\n\n    mod = this.context.submodule;\n    if (mod) {\n      this.modules[mod].fors[value] = 1;\n    }\n  }\n\n};\n\n/**\n * Flatten a string, remove all line breaks and replace them with a token\n * @method implodeString\n * @private\n * @param {String} str The string to operate on\n * @return {String} The modified string\n */\nfunction implodeString (str) {\n  return (str || '').replace(REGEX_GLOBAL_LINES, '!~FIREDOC_LINE~!');\n}\n\n/**\n * Un-flatten a string, replace tokens injected with `implodeString`\n * @method implodeString\n * @private\n * @param {String} str The string to operate on\n * @return {String} The modified string\n */\nfunction explodeString (str) {\n  return (str || '').replace(/!~FIREDOC_LINE~!/g, '\\n');\n}\n\nexports.InitialAST = _.clone(AST);\nexports.AST = AST;\nexports.DIGESTERS = DIGESTERS;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_ast.js"
    },
    {
      "name": "lib_builder.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * The firedoc module\n * @module firedoc\n */\n\nconst _ = require('underscore');\nconst path = require('path');\nconst fs = require('graceful-fs');\nconst fse = require('fs-extra');\nconst mkdirp = require('mkdirp').sync;\nconst inspect = require('util').inspect;\nconst request = require('needle');\nconst Promise = require('bluebird');\nconst Handlebars = require('handlebars');\nconst EventEmitter = require('events').EventEmitter;\n\nconst debug = require('debug')('firedoc:build');\nconst utils = require('./utils');\nconst DocView = require('./docview').DocView;\nconst Locals = require('./locals').Locals;\nconst defaultHelpers = require('./helpers');\n\n/**\n * List of native types to cross link to MDN\n * @property NATIVES\n * @type Object\n */\nconst NATIVES = require('./natives.json');\n\n// Promisify\nPromise.promisifyAll(request);\nPromise.promisifyAll(fs);\nPromise.promisifyAll(fse);\n\n/**\n * The Builder Context\n * @class BuilderContext\n * @extend EventEmitter\n */\nvar BuilderContext = {\n\n  /**\n   * @property {AST} ast - The AST object\n   */\n  ast: null,\n\n  /**\n   * @property {Option} options - The command options\n  */\n  options: null,\n\n  /**\n   * @property {Object} helpers - The view helpers function\n   */\n  helpers: {},\n\n  /**\n   * @property {Boolean} cacheView - cache the views\n   */\n  cacheTemplate: true,\n\n  /**\n   * @property {Object} template - The template\n   */\n  template: null,\n\n  /**\n   * @property {Number} files - records the files\n   */\n  files: 0,\n\n  /**\n   * @property {String} viewExtname - The ext name of current view\n   */\n  get extname () {\n    return this.options.markdown ? '.md' : '.html';\n  },\n\n  /**\n   * load the metadata from theme.json\n   * @method metadata\n   * @return {Object} metadata object\n   */\n  metadata: function () {\n    if (!this._metadata) {\n      try {\n        var metadata;\n        var themeJSON = path.join(this.options.theme, 'theme.json');\n        if (fs.existsSync(themeJSON)) {\n          debug('loading theme from ' + themeJSON);\n          metadata = require(themeJSON);\n        } else {\n          debug('loading the default theme');\n          metadata = require('../themes/default/theme.json');\n        }\n        this._metadata = metadata;\n      } catch (err) {\n        this._metadata = {};\n        console.error(err.stack);\n      }\n    }\n    return this._metadata;\n  },\n\n  /**\n   * Add helper\n   * @method addHelper\n   * @param {String} name - The helper name\n   * @param {Function} helper - The helper logic\n   * @static\n   */\n  addHelper: function (name, helper) {\n    this.helpers[name] = helper;\n    Handlebars.registerHelper(name, helper.bind(this));\n  },\n\n  /**\n   * Add helpers\n   * @method addHelpers\n   * @param {Object} helpers\n   * @static\n   */\n  addHelpers: function (helpers) {\n    _.each(helpers, function (helper, name) {\n      this.addHelper(name, helper);\n    }, this);\n  },\n\n  /**\n   * Ported from [Selleck](https://github.com/rgrove/selleck), this handles ```'s in fields\n   * that are not parsed by the **Markdown** parser.\n   * @method _inlineCode\n   * @private\n   * @param {HTML} html The HTML to parse\n   * @return {HTML} The parsed HTML\n   */\n  inlineCode: function (html) {\n    if (this.options.markdown) return html;\n    html = html.replace(/\\\\`/g, '__{{SELLECK_BACKTICK}}__');\n    html = html.replace(/`(.+?)`/g, function (match, code) {\n      return '<code>' + utils.escapeHTML(code) + '</code>';\n    });\n    html = html.replace(/__\\{\\{SELLECK_BACKTICK\\}\\}__/g, '`');\n    return html;\n  },\n\n  /**\n   * Parse the item to be cross linked and return an HREF linked to the item\n   * @method _parseCrossLink\n   * @private\n   * @static\n   * @param {String} item The item to crossLink\n   * @param {Boolean} [raw=false] Do not wrap it in HTML\n   * @param {String} [content] crossLink helper content\n   */\n  _parseCrossLink: function (item, raw, content) {\n    item = item || 'unknown';\n    var self = this;\n    var base = '../';\n    var baseItem;\n    var newWin = false;\n    var className = 'crosslink';\n\n    // TODO(@yorkie): now remove the unnecessary fixType\n    // will remove this absolutely if this is working for weeks\n    // item = fixType(item);\n    item = baseItem = utils.safetrim(item.replace('{', '').replace('}', ''));\n    item = item.replace('*', '').replace('[', '').replace(']', '');\n    var link = false, href;\n\n    if (self.ast.classes[item]) {\n      link = true;\n    } else {\n      if (self.ast.classes[item.replace('.', '')]) {\n        link = true;\n        item = item.replace('.', '');\n      }\n    }\n    if (self.options.externalData) {\n      if (self.ast.classes[item]) {\n        if (self.ast.classes[item].external) {\n          href = self.ast.classes[item].path;\n          base = self.options.externalData.base;\n          className += ' external';\n          newWin = true;\n          link = true;\n        }\n      }\n    }\n\n    if (item.indexOf('/') > -1) {\n      //We have a class + method to parse\n      var parts = item.split('/'),\n        cls = parts[0],\n        method = parts[1],\n        type = 'method';\n\n      if (method.indexOf(':') > -1) {\n        parts = method.split(':');\n        method = parts[0];\n        type = parts[1];\n        if (type.indexOf('attr') === 0) {\n          type = 'attribute';\n        }\n      }\n\n      if (cls && method) {\n        if (self.ast.classes[cls]) {\n          self.ast.members.forEach(function (i) {\n            if (i.itemtype === type && i.name === method && i.clazz === cls) {\n              link = true;\n              baseItem = method;\n              var t = type;\n              if (t === 'attribute') {\n                t = 'attr';\n              }\n              href = utils.webpath(base, 'classes', cls + '.html#' + t + '_' + method);\n            }\n          });\n        }\n      }\n    }\n\n    if (item === 'Object' || item === 'Array') {\n      link = false;\n    }\n    if (!href) {\n      href = utils.webpath(base, 'classes', item + '.html');\n      if (base.match(/^https?:\\/\\//)) {\n        href = base + utils.webpath('classes', item + '.html');\n      }\n    }\n    if (!link && self.options.linkNatives) {\n      if (NATIVES && NATIVES[item]) {\n        href = linkNativeType(item);\n        if (href) {\n          className += ' external';\n          newWin = true;\n          link = true;\n        }\n      }\n    }\n    if (link) {\n      if (content !== undefined) {\n        content = content.trim();\n      }\n      if (!content) {\n        content = baseItem;\n      }\n      item = '<a href=\"' + href + '\" class=\"' + className + '\"' + ((newWin) ? ' target=\"_blank\"' : '') + '>' + content + '</a>';\n    }\n    return (raw) ? href : item;\n  },\n  \n  /**\n   * Populate the meta data for classes\n   * @method populateClasses\n   * @param {Object} opts The original options\n   * @return {Object} The modified options\n   */\n  populateClasses: function (opts) {\n    var classes = [];\n    var enums = [];\n    _.each(opts.meta.classes, function (clazz) {\n      if (clazz.external) return;\n      if (clazz.isEnum) {\n        clazz.type = 'enums';\n        enums.push(clazz);\n      } else {\n        clazz.type = 'classes';\n        classes.push(clazz);\n      }\n    });\n    opts.meta.classes = _.sortBy(classes, 'name');\n    opts.meta.enums = _.sortBy(enums, 'name');\n    return opts;\n  },\n  \n  /**\n   * Populate the meta data for modules\n   * @method populateModules\n   * @param {Object} opts The original options\n   * @return {Object} The modified options\n   */\n  populateModules: function (opts) {\n    var self = this;\n    var modules = opts.meta.modules;\n    _.each(modules, function (mod) {\n      if (mod.external) return;\n      if (!mod.isSubmodule && mod.submodules) {\n        var submodules = [];\n        _.each(mod.submodules, function (val, name) {\n          var mod = self.ast.modules[name];\n          if (val && mod) submodules.push(mod);\n        });\n        mod.type = 'modules';\n        mod.submodules = _.sortBy(submodules, 'name');\n      }\n    });\n    opts.meta.modules = _.sortBy(modules, 'name');\n    return opts;\n  },\n  \n  /**\n   * Populate the meta data for files\n   * @method populateFiles\n   * @param {Object} opts The original options\n   * @return {Object} The modified options\n   */\n  populateFiles: function (opts) {\n    var self = this;\n    var files = [];\n    _.each(this.ast.files, function (v) {\n      if (v.external) return;\n      v.name = utils.filterFileName(v.name);\n      v.path = v.path || v.name;\n      files.push(v);\n    });\n    files = _.sortBy(files, 'name');\n    opts.meta.fileTree = utils.buildFileTree(files);\n    return opts;\n  },\n  \n  /**\n   * Parses file and line number from an item object and build's an HREF\n   * @method addFoundAt\n   * @param {Object} a The item to parse\n   * @return {String} The parsed HREF\n   */\n  addFoundAt: function (a) {\n    a.foundAt = utils.getFoundAt(a, this.options);\n    return a;\n  },\n\n  /**\n   * Fetches the remote data and fires the callback when it's all complete\n   *\n   * @method mixExternal\n   * @async\n   * @param {Function} cb The callback to execute when complete\n   * @return {Promise}\n   */\n  mixExternal: function (callback) {\n    var self = this;\n    var external = this.options.external || {};\n    var current = Promise.resolve();\n    if (!external) return callback();\n\n    external.merge = external.merge || 'mix';\n    if (!external.data) {\n      console.warn('External config found but no data path defined, skipping import.');\n      if (_.isFunction(callback)) {\n        callback();\n      }\n      return current;\n    }\n    if (!_.isArray(external.data)) {\n      external.data = [external.data];\n    }\n    debug('Importing external documentation data');\n\n    return Promise.map(external.data, function (item) {\n      var base;\n      if (_.isObject(item)) {\n        base = item.base;\n        item = item.json;\n      }\n      if (item.match(/^https?:\\/\\//)) {\n        if (!base) {\n          base = item.replace('data.json', '');\n        }\n        return current.then(function () {\n          debug('fetching ' + item);\n          return request.getAsync(item, {});\n        }).then(function (results) {\n          var data = JSON.parse(results[1]);\n          data.base = base;\n          return data;\n        });\n      } else {\n        if (!base) {\n          base = path.dirname(path.resolve(item));\n        }\n        var data = require(item);\n        data.base = base;\n        return data;\n      }\n    }).then(function (results) {\n      function mixExternal (type, exdata) {\n        self.ast[type] = (exdata[type] || []).map(setExternal);\n      }\n      function setExternal (item) {\n        item.external = true;\n        return item;\n      }\n      _.each(results, function (exdata) {\n        mixExternal('files', exdata);\n        mixExternal('classes', exdata);\n        mixExternal('modules', exdata);\n        mixExternal('members', exdata);\n      });\n      if (_.isFunction(callback)) {\n        callback();\n      }\n    });\n  },\n\n  /**\n   * Makes the default directories needed\n   * @method makeDirs\n   */\n  makeDirs: function (callback) {\n    var dirs = ['assets', 'classes', 'modules', 'enums', 'files'];\n    var root = this.options.dest || 'out';\n    debug('Making default directories: ' + dirs.join(','));\n    mkdirp(path.join(root, dirs[0]));\n    mkdirp(path.join(root, dirs[1]));\n    mkdirp(path.join(root, dirs[2]));\n    mkdirp(path.join(root, dirs[3]));\n    mkdirp(path.join(root, dirs[4]));\n    return dirs;\n  },\n\n  /**\n   * Set `BuilderContext` context and return\n   * @method init\n   * @param {AST} ast\n   * @param {Option} options \n   * @return {BuilderContext}\n   * @static\n   */\n  init: function (ast, options) {\n    this.ast = ast;\n    this.options = options;\n    this.addHelpers(defaultHelpers);\n    this.cacheView = options.cacheView || this.cacheView;\n    this.removeAllListeners();\n    return this;\n  },\n\n  /**\n   * correct the theme\n   * @method correctTheme\n   */\n  correctTheme: function () {\n    var root = path.join(__dirname, '../themes');\n    var theme = root + '/firedoc-theme-' + this.options.theme;\n    if (fs.existsSync(theme))\n      return this.options.theme = theme;\n    theme = root + '/firedoc-plugin-' + this.options.theme;\n    if (fs.existsSync(theme))\n      return this.options.theme = theme;\n    theme = root + '/' + this.options.theme;\n    if (fs.existsSync(theme))\n      return this.options.theme = theme;\n    this.options.theme = root + '/default';\n    return this.options.theme;\n  },\n\n  /**\n   * Compule the AST\n   * @method compile\n   * @static\n   * @param {Function} callback - The callback\n   */\n  compile: function (callback) {\n    debug('Compiling templates...');\n    var self = this;\n    this\n      .mixExternal()\n      .then(function makeDestDirs () {\n        debug('make dest directories');\n        self.makeDirs.call(self);\n      })\n      .then(function checkThemeDir () {\n        debug('Checking theme folder');\n        var theme = self.correctTheme.call(self);\n        var metadata = self.metadata();\n        debug('Using corrected theme: ' + theme);\n        debug('Using the following metadata:' + inspect(metadata, {\n          colors: true\n        }));\n      })\n      .then(function copyAssets () {\n        debug('Copying assets...');\n        var src = self.options.theme + '/assets';\n        var dest = self.options.dest + '/assets';\n        return fse.copyAsync(src, dest);\n      })\n      .then(function createLocalsForTheme () {\n        debug('Creating locals for theme...');\n        return Locals.create(self);\n      })\n      .then(function render (locals) {\n        locals = self.populateFiles(locals);\n        locals = self.populateClasses(locals);\n        locals = self.populateModules(locals);\n        return Promise.all(\n          [\n            self.writeApiMeta(locals),\n            self.writeIndex(locals),\n            self.writeFiles(locals),\n            self.writeEnums(locals),\n            self.writeClasses(locals),\n            self.writeModules(locals)\n          ]\n        );\n      })\n      .then(function onfinish () {\n        debug('Finished the build work');\n        if (_.isFunction(callback)) {\n          callback();\n        }\n      })\n      .caught(callback);\n    return this;\n  },\n\n  /**\n   * Render\n   * @method render\n   */\n  render: function (name, view, locals) {\n    var html = [];\n    var partials = _.extend(locals.partials, {\n      'layout_content': '{{>' + name + '}}'\n    });\n    _.each(partials, function (source, name) {\n      Handlebars.registerPartial(name, source);\n    });\n    if (!this.template || !this.cacheTemplate) {\n      this.template = Handlebars.compile(locals.layouts.main);\n    }\n\n    var _view = {};\n    for (var k in view) {\n      if (_.isFunction(view[k])) {\n        _view[k] = view[k]();\n      } else {\n        _view[k] = view[k];\n      }\n    }\n    return this.inlineCode(this.template(_view));\n  },\n\n  /**\n   * Write api.json\n   * @method writeApiMeta\n   * @param {Locals} locals - The locals\n   */\n  writeApiMeta: function (locals) {\n    var self = this;\n    var apimeta = {\n      project: locals.meta.project,\n      files: locals.meta.files,\n      enums: [],\n      classes: [],\n      modules: []\n    };\n    _.each(\n      ['classes', 'modules', 'enums'],\n      function (id) {\n        var items = locals.meta[id];\n        var g = function (item) {\n          return {\n            'name': item.name,\n            'namespace': item.namespace,\n            'module': item.module,\n            'description': item.description,\n            'access': item.access\n          };\n        }\n        var f = function (item) {\n          apimeta[id].push(g(item));\n          return item && item.submodules;\n        };\n        var s = function (item) {\n          apimeta[id].push(g(item));\n        };\n        var m = function (item) {\n          _.each(item.submodules, s);\n        };\n        _.each(_.filter(locals.meta[id], f), m);\n        apimeta[id] = _.sortBy(apimeta[id], 'name');\n      }\n    );\n    return fs.writeFileAsync(\n      this.options.dest + '/api.json',\n      JSON.stringify(apimeta, null, 2),\n      'utf8'\n    ).then(function () {\n      self.emit('apimeta', apimeta);\n      debug('api.json finished');\n    });\n  },\n\n  writeIndex: function (locals) {\n    debug('Start writing index');\n    var self = this;\n    var view = new DocView(locals.meta);\n    var html = this.render('index', view, locals);\n    var filename = this.options.markdown ? '/readme.md' : '/index.html';\n    var dest = this.options.dest + filename;\n    return fs.writeFileAsync(dest, html, 'utf8').then(function () {\n      self.emit('index', view, html, dest);\n      debug('index.html finished');\n    });\n  },\n\n  writeFiles: function (locals) {\n    debug('Start writing files');\n    var self = this;\n    return Promise.map(\n      locals.meta.files,\n      function (file) {\n        file.globals = locals.meta;\n        var view = new DocView(file, null, '../');\n        var html = self.render('file', view, locals);\n        var dest = path.join(self.options.dest, 'files', file.name.replace(/\\//g, '_') + self.extname);\n        return fs.writeFileAsync(dest, html, 'utf8').then(function () {\n          self.emit('file', view, html, dest);\n          debug(dest + ' finished');\n        });\n      }\n    );\n  },\n\n  writeEnums: function (locals) {\n    debug('Start writing enums');\n    var self = this;\n    return Promise.map(\n      locals.meta.enums,\n      function (e) {\n        e.globals = locals.meta;\n        var view = new DocView(e, null, '../');\n        var html = self.render('enum', view, locals);\n        var dest = path.join(self.options.dest, 'enums', e.name + self.extname);\n        return fs.writeFileAsync(dest, html, 'utf8').then(function () {\n          self.emit('enum', view, html, dest);\n          debug(dest + ' finished');\n        });\n      }\n    );\n  },\n\n  writeClasses: function (locals) {\n    debug('Start writing classes');\n    var self = this;\n    return Promise.map(\n      locals.meta.classes,\n      function (clazz) {\n        clazz.globals = locals.meta;\n        var view = new DocView(clazz, null, '../');\n        var html = self.render('class', view, locals);\n        var dest = path.join(self.options.dest, 'classes', clazz.name + self.extname);\n        return fs.writeFileAsync(dest, html, 'utf8').then(function () {\n          self.emit('class', view, html, dest);\n          debug(dest + ' finished');\n        });\n      }\n    );\n  },\n\n  writeModules: function (locals) {\n    debug('Start writing modules');\n    var self = this;\n    return Promise.map(\n      locals.meta.modules,\n      function (mod) {\n        mod.globals = locals.meta;\n        var view = new DocView(mod, null, '../');\n        var html = self.render('module', view, locals);\n        var dest = path.join(self.options.dest, 'modules', mod.name + self.extname);\n        return fs.writeFileAsync(dest, html, 'utf8').then(function () {\n          self.emit('module', view, html, dest);\n          debug(dest + ' finished');\n        });\n      }\n    );\n  }\n\n};\n\n// Extends the `BuilderContext` with `EventEmitter`.\nvar emitter = new EventEmitter();\nBuilderContext = _.extend(BuilderContext, emitter);\n\n/**\n * Function to link an external type uses `NATIVES` object\n * @method NATIVES_LINKER\n * @private\n * @param {String} name The name of the type to link\n * @return {String} The combined URL\n */\nfunction linkNativeType (name) {\n  name = utils.fixType(name);\n  var url = 'https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/';\n  if (NATIVES[name] !== 1) {\n    url = NATIVES[name];\n  }\n  return url + name;\n}\n\n/**\n * compile\n *\n * @method compile\n * @param {AST} ast - The `AST` object\n * @param {Option} options - The options\n * @param {Function} onfinish - fired when compile has completed\n */\nfunction compile (ast, options, onfinish) {\n  var context = BuilderContext.init(ast, options);\n  setImmediate(function () {\n    context.compile(onfinish);\n  });\n  return context;\n}\nexports.compile = compile;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_builder.js"
    },
    {
      "name": "lib_context.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * The firedoc module\n * @module firedoc\n */\n\nconst _ = require('underscore');\nconst path = require('path');\nconst utils = require('./utils');\nconst debug = require('debug')('firedoc:context');\nconst AST = require('./ast').AST;\n\n/**\n * The ParserContext\n *\n * @class ParserContext\n */\nvar ParserContext = {\n  /**\n   * @property {Any} file - The file\n   */\n  get file () {\n    return this._file;\n  },\n  set file (val) {\n    val = utils.safetrim(val);\n    if (!_.has(this.ast.files, val)) {\n      this.ast.files[val] = {\n        'name': val,\n        'classes': {},\n        'modules': {},\n        'fors': {},\n        'namespaces': {},\n        'code': this.ast.codes[val]\n      };\n    }\n    this._file = val;\n  },\n\n  /**\n   * @property {Any} mainModule\n   */\n  get mainModule () {\n    return this._mainModule;\n  },\n  set mainModule (val) {\n    if (!val) {\n      return;\n    } else {\n      this._mainModule = val;\n    }\n    var write = true;\n    var name = val.mainName || val.name;\n    if (this.module === name) {\n      if (_.has(this.ast.modules, name)) {\n        if (this.ast.modules[name].tag === 'main') {\n          write = false;\n        }\n        if (write) {\n          this.ast.modules[name] = _.extend(this.ast.modules[name], val);\n        }\n      } else {\n        if (val._main) {\n          this.ast.modules[name] = val;\n        }\n      }\n    }\n  },\n\n  /**\n   * @property {Any} module\n   */\n  get module () {\n    return this._module;\n  },\n  set module (val) {\n    var last = {};\n    if (!val) {\n      return;\n    } else {\n      last.module = this.ast.modules[this.module];\n      last.clazz = this.ast.classes[this.clazz];\n      val = utils.safetrim(val);\n      this._module = val;\n      this._clazz = '';\n    }\n    this.submodule = '';\n\n    var main = this.mainModule;\n    if (main && main.name !== val) {\n      this.mainModule = '';\n    }\n\n    if (last.clazz && last.clazz.module !== val) {\n      last.module.classes[last.clazz.name] = last.clazz;\n      if (this.ast.modules[last.clazz.submodule]) {\n        this.ast.modules[last.clazz.submodule].module = last.module.name;\n      }\n    }\n\n    if (!_.has(this.ast.modules, val)) {\n      this.ast.modules[val] = {\n        'name': val,\n        'namespace': val,\n        'classes': {},\n        'submodules': {},\n        'fors': {},\n        'namespaces': {},\n        'types': {}\n      };\n    }\n  },\n\n  /**\n   * @property {Any} process\n   */\n  get clazz () {\n    return this._clazz;\n  },\n  set clazz (val) {\n    if (!val) {\n      return;\n    } else {\n      val = utils.safetrim(val);\n      this._clazz = val;\n    }\n    var clazz;\n    var name = val;\n    if (!_.has(this.ast.classes, val)) {\n      clazz = {\n        'name': name,\n        'shortname': val,\n        'members': [],\n        'plugins': [],\n        'pluginFor': [],\n        'extensions': [],\n        'types': {}\n      };\n      clazz.module = this.module;\n      clazz.submodule = this.submodule || null;\n      clazz.namespace = utils.getNamespace(this);\n      this.ast.classes[name] = clazz;\n    }\n  },\n\n  /**\n   * @property {Any} submodule\n   */\n  get submodule () {\n    return this._submodule;\n  },\n  set submodule (val) {\n    if (!val) return;\n    val = utils.safetrim(val);\n\n    if (!_.has(this.ast.modules, val)) {\n      var mod = {\n        'name': val,\n        'classes': {},\n        'submodules': {},\n        'fors': {},\n        'isSubmodule': true,\n        'namespaces': {},\n        'types': {}\n      };\n      mod.module = this.module;\n      this.ast.modules[val] = mod;\n    }\n    this._submodule = val;\n  },\n\n  /**\n   * @property {Any} block\n   */\n  block: null,\n\n  /**\n   * reset the context\n   * @method reset\n   */\n  reset: function () {\n    this._file = null;\n    this._mainModule = null;\n    this._main = null;\n    this._module = null;\n    this._clazz = null;\n    this._submodule = null;\n    this.block = null;\n  }\n\n};\n\nexports.ParserContext = ParserContext;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_context.js"
    },
    {
      "name": "lib_docparser.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * The firedoc module\n * @module firedoc\n */\n\nconst debug = require('debug')('firedoc:parser');\nconst AST = require('./ast').AST;\n\n/**\n * parse and generate the `AST` object\n *\n * @method parse\n * @param {String} syntaxtype\n * @param {Array} files\n * @param {Array} dirs\n * @return {AST} the ast object\n */\nfunction parse (syntaxtype, files, dirs) {\n  return AST.reset().create(files, dirs, syntaxtype);\n}\n\nexports.parse = parse;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_docparser.js"
    },
    {
      "name": "lib_docview.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "/* global YUI */\n\n/**\n * The firedoc module\n * @module firedoc\n */\n\nconst _ = require('underscore');\nconst path = require('path');\nconst Handlebars = require('handlebars');\n\n/**\n * View class borrowed from [Selleck](https://github.com/rgrove/selleck)  \n * The view class is a **`handlebars`** template helper.\n *\n * @class DocView\n * @constructor\n * @param {Object} data Meta data to use in this template\n * @param {String} templateName The name of the template file to render.\n **/\nfunction DocView (data, templateName, cwd) {\n  this.templateName = templateName;\n  this.cwd = path.join(cwd || '');\n  this.assets = path.join(cwd || '', 'assets');\n  _.extend(this, data);\n\n  // register helpers\n  var self = this;\n  Handlebars.registerHelper('relink', function (item, options) {\n    item = item || '';\n    if (self.project.local) {\n      return '//' + self.project.root + '/' + item;\n    } else {\n      return self.project.baseurl + '/' + item;\n    }\n  });\n}\n\nDocView.prototype = {\n  /**\n   * **Mustache** `lambda` method for setting the HTML title\n   * @method htmlTitle\n   */\n  htmlTitle: function () {\n    var name = this.name;\n    var title = name;\n    try {\n      if (title) {\n        if (this.project.name) {\n          title += ' - ' + this.project.name;\n        }\n      } else {\n        title = this.project.name;\n      }\n    } catch (e) {}\n    return title;\n  },\n\n  /**\n   * **Mustache** `lambda` method for setting the title\n   * @method title\n   */\n  title: function () {\n    var name = this.name;\n    var title = name;\n    try {\n      title = this.project.name;\n      if (name) {\n        title += ': ' + name;\n      }\n    } catch (e) {}\n    return title;\n  }\n\n};\n\nexports.DocView = DocView;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_docview.js"
    },
    {
      "name": "lib_firedoc.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * This is the __module__ description for the `YUIDoc` module.\n * ```\n * var options = {\n *   paths: [ './lib' ],\n *   outdir: './out'\n * };\n * ```\n *\n * @module firedoc\n * @submodule helpers\n * @submodule utils\n * @main firedoc\n */\n\nconst _ = require('underscore');\nconst path = require('path');\nconst fs = require('graceful-fs');\nconst readdirp = require('readdirp');\nconst debug = require('debug')('firedoc');\n\n/**\n * Firedoc main class\n *\n * @class Firedoc\n * @constructor\n * @param config The config object\n */\nfunction Firedoc (config) {\n  if (!(this instanceof Firedoc)) {\n    return new Firedoc(config);\n  }\n\n  /**\n   * Holds the number of files that we are processing.\n   * @property filecount\n   * @type Boolean\n   * @private\n   */\n  this.filecount = 0;\n  /**\n   * Holder for the list of files we are processing.\n   * @property filemap\n   * @type Object\n   * @private\n   */\n  this.filemap = {};\n  /**\n   * Holder for the list of directories we are processing.\n   * @property dirmap\n   * @type Object\n   * @private\n   */\n  this.dirmap = {};\n\n  /**\n   * Internal holder for configuration options.\n   * @property options\n   * @type Object\n   * @private\n   */\n  this.options = {\n    writeJSON: true,\n    extensions: '.js',\n    excludes: [\n      '.git',\n      '.svn',\n      'CVS',\n      'build_rollup_tmp',\n      'build_tmp',\n      'node_modules'\n    ],\n    norecurse: false,\n    path: './',\n    cwd: process.cwd(),\n    theme: path.join(__dirname, '../themes/default'),\n    dest: path.join(process.cwd(), 'out'),\n    syntaxtype: 'js'\n  };\n\n  // setup options\n  var cwd = config.cwd || this.options.cwd;\n  if (fs.existsSync(cwd + '/package.json')) {\n    var pkg = require(cwd + '/package.json');\n    var firedocOption = pkg.firedoc;\n    delete pkg.firedoc;\n    this.options.project = pkg;\n    this.options = _.extend(this.options, firedocOption);\n  } else {\n    this.options.path = config.path || this.options.path;\n  }\n\n  // setup options from config\n  this.options.cwd = config.cwd || this.options.cwd;\n  this.options.dest = config.dest || this.options.dest;\n  this.options.theme = config.theme || this.options.theme;\n  this.options.syntaxtype = config.syntaxtype || this.options.syntaxtype;\n\n  console.log(this.options);\n};\nexports.Firedoc = Firedoc;\n\nFiredoc.prototype = {\n\n  /**\n   * Walks the paths and parses the directory contents\n   *\n   * @method walk\n   * @private\n   */\n  walk: function (callback) {\n    var self = this;\n    readdirp(\n      {\n        root: this.options.path,\n        fileFilter: '*.@(js|rs|ts|coffee)',\n        directoryFilter: self.options.excludes.map(\n          function (ex) {\n            return '!' + ex;\n          }\n        )\n      }\n    ).on('data', function (entry) {\n      var text = fs.readFileSync(entry.fullPath, 'utf8');\n      self.filecount += 1;\n      self.filemap[entry.fullPath] = text.replace(/\\r?\\n|\\r/g, '\\n');\n      self.dirmap[entry.fullPath] = entry.fullParentDir;\n    }).on('end', callback);\n  },\n\n  lint: function (warnings) {\n    var code = 0, count = 0;\n    if (warnings && warnings.length) {\n      code = 1;\n      console.log('YUIDoc found', warnings.length, 'lint errors in your docs');\n      warnings.forEach(function (item) {\n        count++;\n        console.log('#' + count, item.message, item.line + '\\n');\n      });\n    }\n  },\n\n  /**\n   * Process the config, walk the file tree and write out the JSON data.\n   * @method build\n   * @param {Function} callback\n   */\n  build: function (callback) {\n    debug('Starting from: ' + this.options.path);\n    var self = this;\n    this.walk(function () {\n      var parser = require('./docparser');\n      var builder = require('./builder');\n      var ast = parser.parse(\n        self.options.syntaxtype,\n        self.filemap,\n        self.dirmap);\n\n      debug('Parsing completed');\n      if (self.options.lint) {\n        debug('lint the warnings from ast');\n        self.lint(ast.warnings);\n        if (_.isFunction(callback)) return callback(ast.warnings);\n      }\n      if (self.options.parseOnly) {\n        debug('skip the build because parse only');\n        if (_.isFunction(callback)) callback(null, ast, self.options);\n        return;\n      }\n      builder.compile(ast, self.options, callback);\n    });\n  }\n};\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_firedoc.js"
    },
    {
      "name": "lib_helpers.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * The helpers module\n *\n * @module helpers\n * @main helpers\n */\n\nconst _ = require('underscore');\n\n/**\n * Build file tree\n * @method renderFileTree\n */\n// TODO(Yorkie): remove the buildFileTree\nexports.buildFileTree = function onbuildFileTree (items) {\n  var out = '<ul>';\n  _.each(items, function (i, k) {\n    out += '<li>';\n    if (_.isObject(i)) {\n      if (!i.path) {\n        out += k + '/' + onbuildFileTree(i);\n      } else {\n        out += '<a href=\"../files/' + i.name + '.html\">' + k + '</a>';\n      }\n    }\n    out += '</li>';\n  });\n  out += '</ul>';\n  return out;\n};\nexports.renderFileTree = exports.buildFileTree;\n\n/**\n * Create cross link\n * @method crossLink\n */\nexports.crossLink = function oncrossLink (item, options) {\n  var str = '';\n  if (!item) {\n    item = '';\n  }\n  if (item.indexOf('|') > 0) {\n    var parts = item.split('|'),\n      p = [];\n    _.each(parts, function (i) {\n      p.push(this._parseCrossLink.call(this, i));\n    }, this);\n    str = p.join(' | ');\n  } else {\n    str = this._parseCrossLink.call(this, item, false, options.fn(this));\n  }\n  return str;\n};\n\n/**\n * Create cross link module\n * @method crossLinkModule\n */\nexports.crossLinkModule = function oncrossLinkModule (item, options) {\n  var str = item;\n  if (this.ast.modules[item]) {\n    var content = options.fn(this);\n    if (content === \"\") {\n      content = item;\n    }\n    str = '<a href=\"../modules/' + item.replace(/\\//g, '_') +\n          '.html\">' + content + '</a>';\n  }\n  return str;\n};\n\n/**\n * Create cross link to raw\n * @method crossLinkRaw\n */\nexports.crossLinkRaw = function oncrossLinkRaw (item, options) {\n  var str = '';\n  if (!item) {\n    item = '';\n  }\n  if (item.indexOf('|') > 0) {\n    var parts = item.split('|'),\n      p = [];\n    _.each(parts, function (i) {\n      p.push(this._parseCrossLink.call(this, i, true));\n    }, this);\n    str = p.join(' | ');\n  } else {\n    str = this._parseCrossLink.call(this, item, true);\n  }\n  return str;\n};\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_helpers.js"
    },
    {
      "name": "lib_locals.js",
      "classes": {},
      "modules": {},
      "fors": {},
      "namespaces": {},
      "code": "\n/**\n * The firedoc module\n * @module firedoc\n */\n\nconst _ = require('underscore');\nconst path = require('path');\nconst utils = require('./utils');\nconst MarkdownIt = require('markdown-it');\nconst md = new MarkdownIt();\n\n/**\n * The Theme Locals\n * @class Locals\n * @main Locals\n */\nvar Locals = {\n\n  /**\n   * @property {BuilderContext} context - Builder Context\n   */\n  context: null,\n\n  /**\n   * @property {Option} options - The options\n   */\n  options: {},\n\n  /**\n   * @property {AST} ast - The AST object\n   */\n  ast: {},\n\n  /**\n   * @property {Object} project - Get the project to export\n   */\n  get project () {\n    var root;\n    if (path.isAbsolute(this.options.dest)) {\n      root = this.options.dest;\n    } else {\n      root = path.join(process.cwd(), this.options.dest || '');\n    }\n    var proj = this.ast.project;\n    // TODO(Yorkie): support relative path\n    // proj.logo = proj.logo;\n    proj.root = root;\n    proj.assets = path.join(root, '/assets');\n    return proj;\n  },\n\n  /**\n   * @property {Object} i18n - Get i18n object\n   */\n  get i18n () {\n    try {\n      var defaults = require(this.options.theme + '/i18n/en.json');\n      var extra = {};\n      if (this.options.lang) {\n        extra = require(this.options.theme + '/i18n/' + this.options.lang + '.json');\n      }\n      var ret = _.extend(defaults, extra);\n      ret.LANG = this.options.lang || 'en';\n      return ret;\n    } catch (e) {\n      return {};\n    }\n  },\n\n  /**\n   * @property {Object} modules - Get modules object to export\n   */\n  get modules () {\n    var self = this;\n    return Object.keys(self.ast.modules).map(\n      function (name) {\n        var mod = self.ast.modules[name];\n        mod = self.context.addFoundAt(mod);\n        mod.description = self.parseCode(self.markdown(mod.description));\n        mod.members = mod.members || [];\n        mod.project = self.project;\n        mod.globals = self.metadata;\n        mod.i18n = self.i18n;\n        return mod;\n      }\n    );\n  },\n\n  /**\n   * @property {Object} classes - Get classes object to export\n   */\n  get classes () {\n    var self = this;\n    return Object.keys(self.ast.classes).map(\n      function (name) {\n        var clazz = self.ast.classes[name];\n        clazz = self.context.addFoundAt(clazz);\n        clazz = self.appendClassToModule(clazz);\n        clazz.description = self.parseCode(self.markdown(clazz.description));\n        clazz.members = clazz.members || [];\n        clazz.project = self.project;\n        clazz.globals = self.meta;\n        clazz.i18n = self.i18n;\n        clazz.inheritance = self.getInheritanceTree(clazz);\n        if (clazz.isConstructor) {\n          clazz.constructor = self.buildMember(clazz, true);\n        }\n        return clazz;\n      }\n    );\n  },\n\n  /**\n   * @property {Object} files - Get files object to export\n   */\n  get files () {\n    var self = this;\n    return Object.keys(self.ast.files).map(\n      function (name) {\n        var file = self.ast.files[name];\n        file.i18n = self.i18n;\n        return file;\n      }\n    );\n  },\n\n  /**\n   * Initialize the markdownit rulers\n   * @method initMarkdownRulers\n   */\n  initMarkdownRulers: function () {\n    var ast = this.ast;\n    var options = this.options;\n    md.renderer.rules.link_open = function (tokens, idx, ops, env, self) {\n      var token = tokens[idx];\n      if (token && _.isArray(token.attrs)) {\n        token.attrs = token.attrs.map(function (attr, idx) {\n          if (attr[0] === 'href' && \n            /^https?:\\/\\//.test(attr[1]) === false) {\n            var target = ast.namespacesMap[attr[1]];\n            var ext = options.markdown ? '.md' : '.html';\n            if (target.parent && target.itemtype) {\n              var url = target.parent.type + '/' + target.parent.name + ext +\n                '#' + target.itemtype + '_' + target.name;\n              attr[1] = url;\n            }\n          }\n          return attr;\n        });\n      }\n      return self.renderToken(tokens, idx, options);\n    };\n  },\n\n  /**\n   * Parses file and line number from an item object and build's an HREF\n   * @method addFoundAt\n   * @param {Object} a The item to parse\n   * @return {String} The parsed HREF\n   */\n  addFoundAt: function (a) {\n    var self = this;\n    var ext = this.options.markdown ? '.md' : '.html';\n    if (a.file && a.line && !this.options.nocode) {\n      a.foundAt = '../files/' + utils.filterFileName(a.file) + ext + '#l' + a.line;\n      if (a.path) {\n        a.foundAt = a.path + '#l' + a.line;\n      }\n    }\n    return a;\n  },\n\n  /**\n   * build the method name by its name and parameters\n   *\n   * @method getMethodName\n   * @param {String} name - The function/method name\n   * @param {Array} params - The function/method parameters list\n   * @param {String} params.name - The name of the parameter\n   */\n  getMethodName: function (name, params) {\n    return name + '(' + (params || []).map(function (v) {\n      return v.name;\n    }).join(', ') + ')';\n  },\n\n  /**\n   * Parses `<pre><code>` tags and adds the __prettyprint__ `className` to them\n   * @method _parseCode\n   * @private\n   * @param {HTML} html The HTML to parse\n   * @return {HTML} The parsed HTML\n   */\n  parseCode: function (html) {\n    html = html || '';\n    html = html.replace(/<pre><code>/g, '<pre class=\"code prettyprint\"><code>\\n');\n    // TODO(Yorkie): request to underscore, this is not working with &#39;\n    html = html.replace(/&#39;/g, '\\'');\n    return _.unescape(html);\n  },\n\n  /**\n   * Wrapper around the Markdown parser so it can be normalized or even side stepped\n   * @method markdown\n   * @private\n   * @param {String} data The Markdown string to parse\n   * @return {HTML} The rendered HTML\n   */\n  markdown: function (data) {\n    var self = this;\n    if (this.options.markdown) {\n      return data;\n    }\n    var html = md.render(data || '');\n    //Only reprocess if helpers were asked for\n    if (this.options.helpers || (html.indexOf('{{#crossLink') > -1)) {\n      try {\n        // markdown-it auto-escapes quotation marks (and unfortunately\n        // does not expose the escaping function)\n        html = html.replace(/&quot;/g, \"\\\"\");\n        html = (Handlebars.compile(html))({});\n      } catch (hError) {\n        //Remove all the extra escapes\n        html = html.replace(/\\\\{/g, '{').replace(/\\\\}/g, '}');\n        console.warn('Failed to parse Handlebars, probably an unknown helper, skiped');\n      }\n    }\n    return html;\n  },\n\n  /**\n   * append the clazz to its module\n   *\n   * @method appendClassToModule\n   * @param {Object} clazz - The class object\n   * @param {String} clazz.module - The module name of this clazz object\n   */\n  appendClassToModule: function (clazz) {\n    var mod = this.ast.modules[clazz.module];\n    if (mod) {\n      if (!_.isArray(mod.classes)) mod.classes = [];\n      mod.classes.push(clazz);\n    }\n    return clazz;\n  },\n\n  /**\n   * get class inheritance tree\n   *\n   * @method getClassInheritanceTree\n   * @return {Object} return the inheritance tree object\n   */\n  getInheritanceTree: function (clazz) {\n    var children = [];\n    this.ast.inheritedMembers.forEach(function (inherit) {\n      var at = inherit.indexOf(clazz.name);\n      if (at > -1 && at < inherit.length) {\n        var curr = children;\n        for (var i = at + 1; i < inherit.length; i++) {\n          var name = inherit[i];\n          var temp = {'name': name, 'children': []};\n          var needNewChild = true;\n          var pos;\n\n          for (pos = 0; pos < curr.length; pos++) {\n            if (curr[pos].name === name) {\n              needNewChild = false;\n              curr = curr[pos].children;\n              break;\n            }\n          }\n          if (needNewChild) {\n            if (inherit.length - 1 === i) {\n              delete temp.children;\n            }\n            curr.push(temp);\n            if (temp.children) {\n              curr = curr[curr.length - 1].children;\n            }\n          }\n        }\n      }\n    });\n    return children;\n  },\n\n  /**\n   * build the member\n   *\n   * @method buildMember\n   * @param {Object} memeber - The member object\n   * @param {Boolean} forceBeMethod - force make the build process be for method\n   * @param {Object} parent - The parent context\n   * @return {Object} returned member object\n   */\n  buildMember: function (member, forceBeMethod ,parent) {\n    var self = this;\n    member = self.addFoundAt(member);\n    member.description = self.parseCode(self.markdown(member.description || ''));\n    member.hasAccessType = !!member.access;\n    member.readonly = member.readonly === '';\n    member['final'] = member['final'] === '';\n    member.type = member.type || 'Unknown';\n    member.config = member.itemtype === 'config';\n    member.i18n = self.i18n;\n\n    if (!member.class && member.module) {\n      member.parent = self.ast.modules[member.module];\n    } else {\n      member.parent = self.ast.classes[member.class];\n    }\n\n    if (this.options.markdown) {\n      member.markdownLink = utils.markdownLink(member.itemtype + ':' + member.name);\n    }\n    if (member.example) {\n      if (!_.isArray(member.example)) {\n        member.example = [member.example];\n      }\n      member.example = member.example.map(function (v) {\n        return self.parseCode(self.markdown(v.trim()))\n      }).join('');\n    }\n    if (parent) {\n      var classMod = member.submodule || member.module;\n      var parentMod = parent.submodule || parent.module;\n      if (classMod !== parentMod) {\n        member.providedBy = classMod;\n      }\n    }\n    if (member.itemtype === 'method' || forceBeMethod) {\n      member.methodDisplay = self.getMethodName(member.name, member.params);\n      member.hasParams = (member.params || []).length > 0;\n      if (member.hasParams) {\n        _.each(member.params, function (param) {\n          param.description = self.markdown(param.description);\n        });\n      }\n      if (member['return']) {\n        member.hasReturn = true;\n        member.returnType = member['return'].type;\n      } else {\n        member.returnType = '';\n      }\n    }\n    if (member.itemtype === 'attribute') {\n      member.emit = self.options.attributesEmit;\n    }\n    return member;\n  },\n\n  /**\n   * build the members\n   *\n   * @method buildMembers\n   * @return {Boolean} always be true\n   */\n  buildMembers: function () {\n    _.each(\n      this.ast.members,\n      function (member) {\n        var parent;\n        if (member.clazz) {\n          parent = this.ast.classes[member.clazz];\n        } else if (member.module) {\n          parent = this.ast.modules[member.module];\n        }\n        if (!parent) return;\n        if (!parent.members) {\n          parent.members = [];\n        }\n        var item = this.buildMember(member, false, parent);\n        parent.members.push(item);\n      },\n      this\n    );\n  },\n\n  /**\n   * Augments the **DocParser** meta data to provide default values for certain keys as well as parses all descriptions\n   * with the `Markdown Parser`\n   * @method augmentData\n   * @param {Object} o The object to recurse and augment\n   * @return {Object} The augmented object\n   */\n  augmentData: function (o) {\n    var self = this;\n    o = self.addFoundAt(o);\n    _.each(o, function (i, k1) {\n      if (i && i.forEach) {\n        _.each(i, function (a, k) {\n          if (!(a instanceof Object)) {\n            return;\n          }\n          if (!a.type) {\n            a.type = 'Object'; //Default type is Object\n          }\n          if (a.final === '') {\n            a.final = true;\n          }\n          if (!a.description) {\n            a.description = ' ';\n          } else if (!o.extendedFrom) {\n            a.description = self.markdown(a.description);\n          }\n          if (a.example && !o.extendedFrom) {\n            a.example = self.markdown(a.example);\n          }\n          a = self.addFoundAt(a);\n\n          _.each(a, function (c, d) {\n            if (c.forEach || (c instanceof Object)) {\n              c = self.augmentData(c);\n              a[d] = c;\n            }\n          });\n          o[k1][k] = a;\n        });\n      } else if (i instanceof Object) {\n        i.foundAt = utils.getFoundAt(i, self.options);\n        _.each(i, function (v, k) {\n          if (k === 'final') {\n            o[k1][k] = true;\n          } else if (k === 'description' || k === 'example') {\n            if (v.forEach || (v instanceof Object)) {\n              o[k1][k] = self.augmentData(v);\n            } else {\n              o[k1][k] = o.extendedFrom ? v : self.markdown(v);\n            }\n          }\n        });\n      } else if (k1 === 'description' || k1 === 'example') {\n        o[k1] = o.extendedFrom ? i : self.markdown(i);\n      }\n    });\n    return o;\n  },\n\n  /**\n   * Counter for stepping into merges\n   * @private\n   * @property _mergeCounter\n   * @type Number\n   */\n  _mergeCounter: null,\n\n  /**\n   * Merge superclass data into a child class\n   * @method mergeExtends\n   * @param {Object} info The item to extend\n   * @param {Array} members The list of items to merge in\n   * @param {Boolean} first Set for the first call\n   */\n  mergeExtends: function (info, members, first, onmember) {\n    var self = this;\n    self._mergeCounter = (first) ? 0 : (self._mergeCounter + 1);\n\n    if (self._mergeCounter === 100) {\n      throw new Error('YUIDoc detected a loop extending class ' + info.name);\n    }\n    if (info.extends || info.uses) {\n      var hasItems = {};\n      hasItems[info.extends] = 1;\n      if (info.uses) {\n        info.uses.forEach(function (v) {\n          hasItems[v] = 1;\n        });\n      }\n      self.ast.members.forEach(function (v) {\n        if (hasItems[v.clazz]) {\n          if (!v.static) {\n            var q;\n            var override = _.findWhere(members, {'name': v.name});\n            if (!override) {\n              //This method was extended from the parent class but not over written\n              q = _.extend({}, v);\n              q.extendedFrom = v.clazz;\n              members.push(q);\n            } else {\n              //This method was extended from the parent and overwritten in this class\n              q = _.extend({}, v);\n              q = self.augmentData(q);\n              override.overwrittenFrom = q;\n            }\n            if (typeof onmember === 'function') {\n              onmember(q);\n            }\n          }\n        }\n      });\n      if (self.ast.classes[info.extends]) {\n        if (self.ast.classes[info.extends].extends || self.ast.classes[info.extends].uses) {\n          members = self.mergeExtends(self.ast.classes[info.extends], members);\n        }\n      }\n    }\n    return members;\n  },\n\n  /**\n   * generate expand function\n   *\n   * @method getExpandIterator\n   * @private\n   * @param {Object} parent - The object to be set\n   */\n  getExpandIterator: function (parent) {\n    var self = this;\n    var pluralsMap = {\n      'property': 'properties'\n    };\n    return function (item) {\n      if (!item.itemtype) return;\n      var plural = pluralsMap[item.itemtype];\n      if (!plural) {\n        plural = item.itemtype + 's';\n      }\n      if (!parent[plural]) {\n        parent[plural] = [];\n      }\n      parent[plural].push(item);\n    }\n  },\n\n  /**\n   * extends members array\n   *\n   * @method extendMembers\n   * @param {Object} meta - The meta object\n   */\n  extendMembers: function (meta) {\n    _.each(\n      meta.classes, \n      function (clazz) {\n        var inherited = [];\n        clazz.members = this.mergeExtends(clazz, clazz.members, true, function (member) {\n          if (member.extendedFrom) inherited.push(member);\n        });\n        clazz.members.inherited = inherited;\n      }, \n      this\n    );\n  },\n\n  /**\n   * extends modules\n   *\n   * @method expandMembersFromModules\n   * @param {Object} meta - The meta object\n   */\n  expandMembersFromModules: function (meta) {\n    _.each(\n      meta.modules,\n      function (mod) {\n        mod.properties = [];\n        mod.attributes = [];\n        mod.methods = [];\n        mod.events = [];\n        mod.members.forEach(\n          this.getExpandIterator(mod.members)\n        );\n      },\n      this\n    );\n  },\n\n  /**\n   * extends members from classes\n   *\n   * @method expandMembersFromModules\n   * @param {Object} meta - The meta object\n   */\n  expandMembersFromClasses: function (meta) {\n    _.each(\n      meta.classes,\n      function (clazz) {\n        clazz.members.forEach(\n          this.getExpandIterator(clazz.members)\n        );\n        clazz.members.inherited = clazz.members.inherited || [];\n        clazz.members.inherited.forEach(\n          this.getExpandIterator(clazz.members.inherited)\n        );\n      },\n      this\n    );\n  },\n\n  /**\n   * Create a locals object from context\n   *\n   * @method create\n   * @param {BuilderContext} context - The `BuilderContext` instance\n   */\n  create: function (context) {\n    this.context = context;\n    this.options = context.options;\n    this.ast = context.ast;\n    this.initMarkdownRulers();\n\n    var instance = utils.prepare([this.options.theme], this.options);\n    instance.meta.classes = this.classes;\n    instance.meta.modules = this.modules;\n\n    // attach/build members to classes and modules\n    this.buildMembers();\n\n    // set files i18n and globals\n    instance.meta.files = this.files;\n    instance.meta.i18n = this.i18n;\n    instance.meta.globals = instance.meta;\n\n    // merge extends\n    this.extendMembers(instance.meta);\n    this.expandMembersFromModules(instance.meta);\n    this.expandMembersFromClasses(instance.meta);\n\n    // build locals.js\n    var locals;\n    var meta = instance.meta;\n    try {\n      locals = require(this.options.theme + '/locals.js');\n    } catch (e) {\n      locals = function () {};\n    }\n    locals(meta.modules, meta.classes, meta);\n    return instance;\n  }\n\n};\n\nexports.Locals = Locals;\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_locals.js"
    },
    {
      "name": "lib_utils.js",
      "classes": {},
      "modules": {},
      "fors": {
        "DocParser": 1
      },
      "namespaces": {},
      "code": "/*jshint onevar:false */\n\n/**\n * Utilities modules\n * @module utils\n */\n\nconst _ = require('underscore');\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst minimatch = require('minimatch');\nconst HTML_CHARS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '/': '&#x2F;',\n  '`': '&#x60;'\n};\n\n/**\n * Format the process string to array\n * @method fmtProcess\n * @param {String} process\n * @return {Array} The process array\n */\nfunction fmtProcess (process) {\n  return process.split(',').map(safetrim);\n}\nexports.fmtProcess = fmtProcess;\n\n/**\n * Get the namespace string from a target object\n * @method getNamespace\n * @param {Object} target\n * @param {String} target.module\n * @param {String} target.clazz\n * @param {String} target.name\n * @return {String} The namespace string\n */\nfunction getNamespace (target) {\n  var nssource = [target.module, target.clazz, target.name];\n  return nssource.filter(function (item) {\n    return !!item;\n  }).join('.');\n}\nexports.getNamespace = getNamespace;\n\n/**\n * Escapes HTML characters in _html_.\n *\n * @method escapeHTML\n * @param {String} html String to escape.\n * @return {String} Escaped string.\n **/\nfunction escapeHTML (html) {\n  return html.replace(/[&<>\"'\\/`]/g, function (m) {\n    return HTML_CHARS[m];\n  });\n}\nexports.escapeHTML = escapeHTML;\n\n/**\n * Trim in safe mode\n *\n * @method safetrim\n * @param {String} str\n * @return {String} trimed string or other types if invalid\n */\nfunction safetrim (str) {\n  if (str && _.isFunction(str.trim)) {\n    return str.trim();\n  } else {\n    return String(str || '').trim();\n  }\n}\nexports.safetrim = safetrim;\n\n/**\n * Normalizes the initial indentation of the given _content_ so that the first line\n * is unindented, and all other lines are unindented to the same degree as the\n * first line. So if the first line has four spaces at the beginning, then all\n * lines will be unindented four spaces. Ported from [Selleck](https://github.com/rgrove/selleck)\n *\n * @method unindent\n * @param {String} content Text to unindent.\n * @return {String} Unindented text.\n**/\nfunction unindent (contents) {\n  var indent = contents.match(/^(\\s+)/);\n  if (indent) {\n    contents = contents.replace(new RegExp('^' + indent[1], 'gm'), '');\n  }\n  return contents;\n}\nexports.unindent = unindent;\n\n/**\n * Normalizes a file path to a writable filename:\n *\n *    var path = 'lib/file.js';\n *    returns 'lib_file.js';\n *\n * @method filterFileName\n * @param {String} f The filename to normalize\n * @return {String} The filtered file path\n */\nfunction filterFileName (f) {\n  return (f || '').replace(/[\\/\\\\]/g, '_');\n}\nexports.filterFileName = filterFileName;\n\n/**\n * Parses file and line number from an item object and build's an HREF\n * @method getFoundAt\n * @param {Object} obj - The item to parse\n * @param {Object} options - The options\n * @param {Boolean} options.markdown - If in markdown mode\n * @param {Boolean} options.nocode - If no code\n * @return {String} The parsed HREF\n */\nfunction getFoundAt (obj, options) {\n  var ext = options.markdown ? '.md' : '.html';\n  var ret = '';\n  if (obj.file && obj.line && !options.nocode) {\n    if (obj.path) {\n      ret = obj.path + '#l' + obj.line;\n    } else {\n      ret = '../files/' + filterFileName(obj.file) + ext + '#l' + obj.line;\n    }\n  }\n  return ret;\n}\nexports.getFoundAt = getFoundAt;\n\n/**\n * Like `getPages()`, but returns only the files under the `layout/` subdirectory\n * of the specified _dir_.\n *\n * @method getLayouts\n * @param {String} dir Directory path.\n * @return {Object} Mapping of layout names to layout content.\n **/\nfunction getLayouts (dir) {\n  if (!_.isString(dir)) return {};\n  return getPages(path.join(dir, 'layouts'));\n}\nexports.getLayouts = getLayouts;\n\n/**\n * Loads and returns the content of the specified page file.\n *\n * @method getPage\n * @param {String} p - Path to a single `.handlebars` page.\n * @return {String|null} Page content, or `null` if not found.\n **/\nfunction getPage (p) {\n  var stat = fs.statSync(p);\n  if (stat.isFile()) {\n    return fs.readFileSync(p, 'utf8');\n  } else {\n    return null;\n  }\n}\nexports.getPage = getPage;\n\n/**\n * Loads pages (files with a `.handlebars` extension) in the specified directory and\n * returns an object containing a mapping of page names (the part of the filename)\n * preceding the `.handlebars` extension) to page content.\n *\n * @method getPages\n * @param {String} dir Directory path.\n * @return {Object} Mapping of page names to page content.\n **/\nvar cache = {};\nfunction getPages (dir, useMarkdown) {\n  if (cache[dir]) {\n    return cache[dir];\n  }\n  var pages = {};\n  var stat = fs.statSync(dir);\n  if (!stat.isDirectory()) {\n    return pages;\n  }\n\n  _.each(\n    fs.readdirSync(dir),\n    function (name) {\n      var p = path.join(dir, name);\n      var ext = useMarkdown ? '.mdt' : '.handlebars';\n      if (path.extname(name) === ext && fs.statSync(p).isFile()) {\n        var name = path.basename(name, ext);\n        var text = fs.readFileSync(p, 'utf8');\n        Object.defineProperty(pages, name, {\n          enumerable: true,\n          get: function () {\n            return text\n          },\n          set: function () {}\n        });\n      }\n    }\n  );\n  cache[dir] = pages;\n  return pages;\n}\nexports.getPages = getPages;\n\n/**\n * Like `getPages()`, but returns only the files under the `partial/` subdirectory\n * of the specified _dir_.\n *\n * @method getPartials\n * @param {String} dir Directory path.\n * @return {Object} Mapping of partial names to partial content.\n **/\nfunction getPartials (dir) {\n  if (!_.isString(dir)) return {};\n  return getPages(path.join(dir, 'partials'));\n}\nexports.getPartials = getPartials;\n\n/**\n * Mix/merge/munge data into the template.\n *\n * @method prepare\n * @param {String} inDir The starting directory\n * @param {Object} options The `options` for the meta data.\n * @param {callback} callback The callback to excecute when complete\n * @param {Error} callback.err\n * @param {Object} callback.options Merged options.\n **/\nfunction prepare (inDirs, options, callback) {\n  var layouts, partials, type = 'project';\n  var defaults = {\n    'meta': {\n      'project': options.project,\n      'component': {}\n    },\n    'pages': {},\n    'layouts': {},\n    'partials': {},\n    'viewClass': require('./docview').DocView\n  };\n\n  if (options && options.skipLoad) {\n    // Skip loading layouts, metadata, pages, and partials and assume that\n    // the caller has provided them if they want them.\n    options = _.extend(defaults, options);\n  } else {\n    // Gather layouts, metadata, pages, and partials from the specified\n    // input directory, then merge them into the provided options (if any).\n    //\n    // Gathered data will override provided data if there are conflicts, in\n    // order to support a use case where global data are provided by the\n    // caller and overridden by more specific component-level data gathered\n    // from the input directory.\n    //\n    // The metadata inheritance chain looks like this:\n    //\n    //   - override metadata specified via CLI (highest precedence)\n    //   - component metadata (if this is a component)\n    //   - project-level component default metadata (if specified and this is a component)\n    //   - theme-level component default metadata (if specified and this is a component)\n    //   - project metadata\n    //   - theme metadata (lowest precedence)\n    if (inDirs[0] === inDirs[1]) {\n      layouts = getLayouts(inDirs[0]);\n      partials = getPartials(inDirs[0]);\n    } else {\n      layouts = _.extend(\n        getLayouts(inDirs[0]), \n        getLayouts(inDirs[1])\n      );\n      partials = _.extend(\n        getPartials(inDirs[0]),\n        getPartials(inDirs[1])\n      );\n    }\n    options = _.extend(defaults, options);\n    options = _.extend(options, {\n      'layouts': layouts,\n      'partials': partials,\n    });\n  }\n\n  // Set a default asset path if one isn't specified in the metadata.\n  if (!options.meta.component.assets && options.component) {\n    options.meta.component.assets = '../assets/' + options.meta.name;\n  }\n  if (_.isUndefined(options.meta.layout)) {\n    options.meta.layout = options.layouts[type] ? type : 'main';\n  }\n  if (_.isFunction(callback)) {\n    callback(null, options);\n  }\n  return options;\n}\nexports.prepare = prepare;\n\n/**\n * Takes a type string and converts it to a \"First letter upper cased\" type. \n * e.g. `(string -> String, object -> Object)`\n *\n * @method fixType\n * @param {String} t The type string to convert\n * @return {String} The fixed string\n */\nfunction fixType (t) {\n  t = safetrim(t);\n  if (t && t.indexOf('.') === -1) {\n    t = t.replace(/{/g, '').replace(/}/g, '');\n    var firstChar = t.charAt(0),\n      upperFirstChar = firstChar.toUpperCase();\n\n    if (firstChar !== upperFirstChar) {\n      return upperFirstChar + t.substring(1);\n    }\n  }\n  return t;\n};\nexports.fixType = fixType;\n\n/**\n * Produces a normalized web path by joining all the parts and normalizing the\n * filesystem-like path into web compatible url.\n * Supports relative and absolute paths.\n * Courtesy of [Mojito's utils](https://github.com/yahoo/mojito/)\n *\n * @method webpath\n * @param {Array|String*} url the list of parts to be joined and normalized\n * @return {String} The joined and normalized url\n **/\nfunction webpath (url) {\n  var args = [].concat.apply([], arguments),\n    parts = path.join.apply(path, args).split(/[\\\\\\/]/);\n  return parts.join('/');\n}\nexports.webpath = webpath;\n\n/**\n * Localize the string via current Y.options\n *\n * @method localize\n * @param str {String} the original string that you want to input\n * @param lang {String} the language\n * @return {String} localized string from the param `str`\n */\nfunction localize (str, lang) {\n  var splitedStrArr = (str || '').split('!#');\n  var supportedLang = ['en', 'zh'];\n  return splitedStrArr.map(function(block) {\n    var langFlag = block.slice(0, 2);\n    var selectedLang = supportedLang.indexOf(langFlag);\n    if (selectedLang === -1) {\n      // default language is 'en'\n      return {\n        raw: block,\n        all: true\n      };\n    } else {\n      return {\n        raw: block.slice(2),\n        lang: supportedLang[selectedLang]\n      };\n    }\n  }).filter(function(block) {\n    if (!block || !block.raw) {\n      return false;\n    }\n    if (block.all) {\n      return true;\n    }\n    return block.lang === (lang || 'en');\n  }).map(function(block) {\n    return block.raw.trim();\n  }).join('\\n');\n}\nexports.localize = localize;\n\n/**\n * convert string to markdown link\n *\n * @method markdownLink\n * @param {String} str - The original string that you want to input\n * @return {String} marked string from the param `str`\n */\nfunction markdownLink (str) {\n  return str\n    .replace(/[:,]/g, '-')\n    .replace(/[\\s\\(\\)\\[\\]=]/g, '')\n    .toLowerCase();\n}\nexports.markdownLink = markdownLink;\n\n/**\n * build file tree object\n *\n * @method buildFileTree\n * @param {Array} files\n * @return {Object}\n */\nfunction buildFileTree (files) {\n  var tree = {};\n  _.each(files, function (v) {\n    var p = v.name.split('/');\n    var par;\n    p.forEach(function (i, k) {\n      if (!par) {\n        if (!tree[i]) {\n          tree[i] = {};\n        }\n        par = tree[i];\n      } else {\n        if (!par[i]) {\n          par[i] = {};\n        }\n        if (k + 1 === p.length) {\n          par[i] = {\n            path: v.name,\n            name: filterFileName(v.name)\n          };\n        }\n        par = par[i];\n      }\n    });\n  });\n  return tree;\n}\nexports.buildFileTree = buildFileTree;\n\n/**\n * Parses the JSON data and formats it into a nice log string for\n * filename and line number: `/file/name.js:123`\n * @method stringlog\n * @private\n * @param {Object} data The data block from the parser\n * @return {String} The formatted string.\n * @for DocParser\n */\nfunction stringlog(data) {\n  var line, file;\n  if (data.file && data.line) {\n    file = data.file;\n    line = data.line;\n  } else {\n    data.forEach(function (d) {\n      if (d.tag === 'file') {\n        file = d.value;\n      }\n      if (d.tag === 'line') {\n        line = d.value;\n      }\n    });\n  }\n  return ' ' + file + ':' + line;\n}\nexports.stringlog = stringlog;\n\n",
      "i18n": {
        "sidebar": {
          "CLASSES": "Classes",
          "MODULES": "Modules",
          "ENUMS": "Enums",
          "SEARCH_PLACEHOLDER": "Type to filter APIs"
        },
        "options": {
          "SHOW": "Show",
          "PROTECTED": "Protected",
          "PRIVATE": "Private",
          "DEPRECATED": "Deprecated"
        },
        "INDEX_WELCOME": "Browse to a module or class using the sidebar to view its API documentation.",
        "INDEX_TITLE": "Keyboard Shortcuts",
        "INDEX_GUIDES_1": "ress <kbd>s</kbd> to focus the API search box.",
        "INDEX_GUIDES_2": "Use <kbd>Up</kbd> and <kbd>Down</kbd> to select classes, modules, and search results.",
        "INDEX_GUIDES_3": "With the API search box or sidebar focused, use <kbd><span class='cmd'>&#x2318;</span>-Left</kbd> or <kbd><span class='cmd'>&#x2318;</span>-Right</kbd> to switch sidebar tabs.",
        "INDEX_GUIDES_4": "With the API search box or sidebar focused, use <kbd>Ctrl+Left</kbd> and <kbd>Ctrl+Right</kbd> to switch sidebar tabs.",
        "INDEX": "Index",
        "STATIC": "static",
        "DEPRECATED": "deprecated",
        "CHAINABLE": "chainable",
        "ASYNC": "async",
        "OPTIONAL": "optional",
        "DEFAULTS": "default",
        "EXAMPLES": "examples",
        "PARAMETERS": "parameters",
        "RETURNS": "returns",
        "TYPE": "type",
        "CLASS": "Class",
        "MODULE": "Module",
        "ENUM": "Enum",
        "PARENT_MODULE": "Parent Module",
        "PROPERTIES": "Properties",
        "ATTRUBUTES": "Attributes",
        "METHODS": "Methods",
        "EVENTS": "Events",
        "INHERITED_MEMBERS": "inherited members",
        "INHERITANCE_TREE": "Inheritance Tree",
        "CONSTRUCTOR": "Constructor",
        "DEFINED_IN": "Defined in",
        "EXTENDS_FOR": "Extends",
        "INHERITED_FROM": "Inherited from",
        "LANG": "en"
      },
      "path": "lib_utils.js"
    }
  ],
  "enums": [],
  "classes": [
    {
      "name": "AST",
      "namespace": "firedoc.AST",
      "module": "firedoc",
      "description": "<p>The AST(Abstract syntax tree) of the comment</p>\n"
    },
    {
      "name": "BuilderContext",
      "namespace": "firedoc.BuilderContext",
      "module": "firedoc",
      "description": "<p>The Builder Context</p>\n"
    },
    {
      "name": "DocParser",
      "namespace": "firedoc.DocParser",
      "module": "firedoc",
      "description": ""
    },
    {
      "name": "DocView",
      "namespace": "firedoc.DocView",
      "module": "firedoc",
      "description": "<p><p>View class borrowed from <a href=\"https://github.com/rgrove/selleck\">Selleck</a>\nThe view class is a <strong><code>handlebars</code></strong> template helper.</p></p>\n"
    },
    {
      "name": "Firedoc",
      "namespace": "firedoc.Firedoc",
      "module": "firedoc",
      "description": "<p><p>Firedoc main class</p></p>\n"
    },
    {
      "name": "Locals",
      "namespace": "firedoc.Locals",
      "module": "firedoc",
      "description": "<p>The Theme Locals</p>\n"
    },
    {
      "name": "ParserContext",
      "namespace": "firedoc.ParserContext",
      "module": "firedoc",
      "description": "<p>The ParserContext</p>\n"
    }
  ],
  "modules": [
    {
      "name": "firedoc",
      "namespace": "firedoc",
      "description": "<p>The firedoc module</p>\n"
    },
    {
      "name": "helpers",
      "module": "firedoc",
      "description": "<p>The helpers module</p>\n"
    },
    {
      "name": "helpers",
      "module": "firedoc",
      "description": "<p>The helpers module</p>\n"
    },
    {
      "name": "utils",
      "module": "firedoc",
      "description": "<p>Utilities modules</p>\n"
    },
    {
      "name": "utils",
      "module": "firedoc",
      "description": "<p>Utilities modules</p>\n"
    }
  ]
}